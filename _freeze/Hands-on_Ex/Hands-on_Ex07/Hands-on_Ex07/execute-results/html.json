{
  "hash": "7ae052f911fb881e776843c15c7405b8",
  "result": {
    "markdown": "---\ntitle: \"Hands-on Exercise 7: Geographical Segmentation with Spatially Constrained Clustering Techniques\"\nformat: \n  html:\n    code-summary: \"Show code\"\n    toc-depth: 3\n    code-overflow: \"scroll\"\nauthor: \"Alexander Vincent Lewi\"\ndate: \"10 March 2024\"\nexecute: \n  freeze: true\n  message: false\n  warning: false\n---\n\n\n## Overview\n\nThis hands-on exercise will focus on the application of clustering techniques to perform geographical segmentation. There are two major types of techniques:\n\n-   hierarchical cluster analysis; and\n-   spatially constrained cluster analysis.\n\nIt is a common practice to use clustering techniques to segment the market or planning area into different zones. In this exercise, we will try to delineate [Shan State](https://en.wikipedia.org/wiki/Shan_State), [Myanmar](https://en.wikipedia.org/wiki/Myanmar), into different zones based on multiple Information and Communication technology (ICT) measures, namely: Radio, Television, Land line phone, Mobile phone, Computer, and Internet at home.\n\n## Imports\n\n### Packages\n\nThe R packages needed for this exercise are as follows:\n\n-   Spatial data handling\n\n    -   **sf**, **rgdal** and **spdep**\n\n-   Attribute data handling\n\n    -   **tidyverse**, especially **readr**, **ggplot2** and **dplyr**\n\n-   Choropleth mapping\n\n    -   **tmap**\n\n-   Multivariate data visualisation and analysis\n\n    -   **coorplot**, **ggpubr**, and **heatmaply**\n\n-   Cluster analysis\n\n    -   **cluster**\n\n    -   **ClustGeo**\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(rgdal, spdep, tmap, sf, ClustGeo, \n               ggpubr, cluster, factoextra, NbClust,\n               heatmaply, corrplot, psych, tidyverse, GGally)\n```\n:::\n\n\n### Data\n\nBoth data sets are download from [Myanmar Information Management Unit (MIMU)](http://themimu.info/)\n\n#### Aspatial Data\n\nInfoComm variables extracted from [The 2014 Myanmar Population and Housing Census Myanmar](https://myanmar.unfpa.org/en/publications/2014-population-and-housing-census-myanmar-data-sheet) at the township level. The attribute data set is called ict. It is saved in R’s **tibble data.frame** format.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nict <- read_csv (\"data/aspatial/Shan-ICT.csv\")\n```\n:::\n\n\n#### Geospatial Data\n\nMyanmar township boundaries are downloaded from [Myanmar Information Management Unit (MIMU)](http://themimu.info/). The geospatial data set is called myanmar_township_boundaries. It is saved in ESRI shapefile format.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshan_sf <- st_read(dsn = \"data/geospatial\", \n                   layer = \"myanmar_township_boundaries\") %>%\n  filter(ST %in% c(\"Shan (East)\", \"Shan (North)\", \"Shan (South)\")) %>%\n  select(c(2:7))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nReading layer `myanmar_township_boundaries' from data source \n  `C:\\SMU\\Y3T2\\IS415 Geospatial Analytics and Applications\\IS415-GAA\\Hands-on_Ex\\Hands-on_Ex07\\data\\geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 330 features and 14 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 92.17275 ymin: 9.671252 xmax: 101.1699 ymax: 28.54554\nGeodetic CRS:  WGS 84\n```\n:::\n:::\n\n\n### Data Preparation\n\nWe will now derive new variables from the ict data set. Since the unit of measurements for each variables are the number of households, it creates bias towards townships with larger population. To mitigate this bias, we will derive new variables that are the proportion of households with Radio, Television, Land line phone, Mobile phone, Computer, and Internet at home.\n\nThe new variables are calculated per 1000 households. The new variables are named `RADIO_PR`, `TV_PR`, `LLPHONE_PR`, `MPHONE_PR`, `COMPUTER_PR`, and `INTERNET_PR`. The new variables are then renamed to more intuitive names. The derived data set is called ict_derived.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nict_derived <- ict %>%\n  mutate(`RADIO_PR` = `Radio`/`Total households`*1000) |>\n  mutate(`TV_PR` = `Television`/`Total households`*1000) |>\n  mutate(`LLPHONE_PR` = `Land line phone`/`Total households`*1000) |>\n  mutate(`MPHONE_PR` = `Mobile phone`/`Total households`*1000) |>\n  mutate(`COMPUTER_PR` = `Computer`/`Total households`*1000) |>\n  mutate(`INTERNET_PR` = `Internet at home`/`Total households`*1000) |>\n  rename(`DT_PCODE` =`District Pcode`,`DT`=`District Name`,\n         `TS_PCODE`=`Township Pcode`, `TS`=`Township Name`,\n         `TT_HOUSEHOLDS`=`Total households`,\n         `RADIO`=`Radio`, `TV`=`Television`, \n         `LLPHONE`=`Land line phone`, `MPHONE`=`Mobile phone`,\n         `COMPUTER`=`Computer`, `INTERNET`=`Internet at home`) \n```\n:::\n\n\n## Exploratory Data Analysis (EDA)\n\n### Statistical Graphics\n\nNow we will conduct univariate analysis to understand the distribution of each variable. We will use histograms to visualise the distribution of each variable. We will use boxplots as well to detect if there are outliers.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Plot original variables\"}\nradio_hist <- ggplot(data=ict_derived, \n             aes(x= `RADIO`)) +\n  geom_histogram(bins=20, \n                 color=\"black\", \n                 fill=\"light blue\")\n\nradio_box <- ggplot(data=ict_derived, \n                    aes(x=`RADIO`)) +\n  geom_boxplot(color=\"black\", \n               fill=\"light blue\")\n\ntv_hist <- ggplot(data=ict_derived, \n             aes(x= `TV`)) +\n  geom_histogram(bins=20, \n                 color=\"black\", \n                 fill=\"light blue\")\n\ntv_box <- ggplot(data=ict_derived, \n                    aes(x=`TV`)) +\n  geom_boxplot(color=\"black\",\n               fill=\"light blue\")\n\nllphone_hist <- ggplot(data=ict_derived, \n             aes(x= `LLPHONE`)) +\n  geom_histogram(bins=20, \n                 color=\"black\", \n                 fill=\"light blue\")\n\nllphone_box <- ggplot(data=ict_derived, \n                    aes(x=`LLPHONE`)) +\n  geom_boxplot(color=\"black\",\n               fill=\"light blue\")\n\nmphone_hist <- ggplot(data=ict_derived, \n             aes(x= `MPHONE`)) +\n  geom_histogram(bins=20, \n                 color=\"black\", \n                 fill=\"light blue\")\n\nmphone_box <- ggplot(data=ict_derived, \n                    aes(x=`MPHONE`)) +\n  geom_boxplot(color=\"black\",\n               fill=\"light blue\")\n\ncomputer_hist <- ggplot(data=ict_derived, \n             aes(x= `COMPUTER`)) +\n  geom_histogram(bins=20, \n                 color=\"black\", \n                 fill=\"light blue\")\n\ncomputer_box <- ggplot(data=ict_derived, \n                    aes(x=`COMPUTER`)) +\n  geom_boxplot(color=\"black\",\n               fill=\"light blue\")\n\ninternet_hist <- ggplot(data=ict_derived, \n             aes(x= `INTERNET`)) +\n  geom_histogram(bins=20, \n                 color=\"black\", \n                 fill=\"light blue\")\n\ninternet_box <- ggplot(data=ict_derived, \n                    aes(x=`INTERNET`)) +\n  geom_boxplot(color=\"black\",\n               fill=\"light blue\")\n\nggarrange(radio_hist, radio_box,\n          tv_hist, tv_box,\n          llphone_hist, llphone_box,\n          mphone_hist, mphone_box,\n          computer_hist, computer_box,\n          internet_hist, internet_box,\n          ncol = 2, \n          nrow = 6)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex07_files/figure-html/unnamed-chunk-5-1.png){width=480}\n:::\n:::\n\n\nAs you can see, most of the variables are right-skewed. Luckily, we have addressed this issue in the previous section. Let's now plot the newly derived variables.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Plot new variables\"}\nradio_hist <- ggplot(data=ict_derived, \n             aes(x= `RADIO_PR`)) +\n  geom_histogram(bins=20, \n                 color=\"black\", \n                 fill=\"light blue\")\n\nradio_box <- ggplot(data=ict_derived, \n                    aes(x=`RADIO_PR`)) +\n  geom_boxplot(color=\"black\", \n               fill=\"light blue\")\n\ntv_hist <- ggplot(data=ict_derived, \n             aes(x= `TV_PR`)) +\n  geom_histogram(bins=20, \n                 color=\"black\", \n                 fill=\"light blue\")\n\ntv_box <- ggplot(data=ict_derived, \n                    aes(x=`TV_PR`)) +\n  geom_boxplot(color=\"black\",\n               fill=\"light blue\")\n\nllphone_hist <- ggplot(data=ict_derived, \n             aes(x= `LLPHONE_PR`)) +\n  geom_histogram(bins=20, \n                 color=\"black\", \n                 fill=\"light blue\")\n\nllphone_box <- ggplot(data=ict_derived, \n                    aes(x=`LLPHONE_PR`)) +\n  geom_boxplot(color=\"black\",\n               fill=\"light blue\")\n\nmphone_hist <- ggplot(data=ict_derived, \n             aes(x= `MPHONE_PR`)) +\n  geom_histogram(bins=20, \n                 color=\"black\", \n                 fill=\"light blue\")\n\nmphone_box <- ggplot(data=ict_derived, \n                    aes(x=`MPHONE_PR`)) +\n  geom_boxplot(color=\"black\",\n               fill=\"light blue\")\n\ncomputer_hist <- ggplot(data=ict_derived, \n             aes(x= `COMPUTER_PR`)) +\n  geom_histogram(bins=20, \n                 color=\"black\", \n                 fill=\"light blue\")\n\ncomputer_box <- ggplot(data=ict_derived, \n                    aes(x=`COMPUTER_PR`)) +\n  geom_boxplot(color=\"black\",\n               fill=\"light blue\")\n\ninternet_hist <- ggplot(data=ict_derived, \n             aes(x= `INTERNET_PR`)) +\n  geom_histogram(bins=20, \n                 color=\"black\", \n                 fill=\"light blue\")\n\ninternet_box <- ggplot(data=ict_derived, \n                    aes(x=`INTERNET_PR`)) +\n  geom_boxplot(color=\"black\",\n               fill=\"light blue\")\n\nggarrange(radio_hist, radio_box,\n          tv_hist, tv_box,\n          llphone_hist, llphone_box,\n          mphone_hist, mphone_box,\n          computer_hist, computer_box,\n          internet_hist, internet_box,\n          ncol = 2, \n          nrow = 6)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex07_files/figure-html/unnamed-chunk-6-1.png){width=480}\n:::\n:::\n\n\n### Choropleth\n\n#### Joinning geospatial data with aspatial data\n\nBefore we can proceed with the choropleth mapping, we need to join the geospatial data with the aspatial data. We will use the `left_join` function from the **dplyr** package to join the two data sets. The join key is the township code. The joined data set is called shan_sf.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshan_sf <- left_join(shan_sf, \n                     ict_derived, by=c(\"TS_PCODE\"=\"TS_PCODE\"))\n  \nwrite_rds(shan_sf, \"data/rds/shan_sf.rds\")\n```\n:::\n\n::: {.cell}\n\n:::\n\n\n#### Choropleth Mapping\n\n\n::: {.cell}\n\n```{.r .cell-code}\nqtm(shan_sf, \"RADIO_PR\")\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex07_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n:::\n\n\nIn order to reveal the distribution shown in the choropleth map above are bias to the underlying total number of households at the townships, we will create two choropleth maps, one for the total number of households (i.e. TT_HOUSEHOLDS.map) and one for the total number of household with Radio (RADIO.map) by using the code chunk below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nTT_HOUSEHOLDS.map <- tm_shape(shan_sf) + \n  tm_fill(col = \"TT_HOUSEHOLDS\",\n          n = 5,\n          style = \"jenks\", \n          title = \"Total households\") + \n  tm_borders(alpha = 0.5) \n\nRADIO.map <- tm_shape(shan_sf) + \n  tm_fill(col = \"RADIO\",\n          n = 5,\n          style = \"jenks\",\n          title = \"Number Radio \") + \n  tm_borders(alpha = 0.5) \n\ntmap_arrange(TT_HOUSEHOLDS.map, RADIO.map,\n             asp=NA, ncol=2)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex07_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n:::\n\n\nNotice that the choropleth maps above clearly show that townships with relatively larger number ot households are also showing relatively higher number of radio ownership.\n\nNow let us plot the choropleth maps showing the dsitribution of total number of households and Radio penetration rate by using the code chunk below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(shan_sf) +\n    tm_polygons(c(\"TT_HOUSEHOLDS\", \"RADIO_PR\"),\n                style=\"jenks\") +\n    tm_facets(sync = TRUE, ncol = 2) +\n  tm_legend(legend.position = c(\"right\", \"bottom\"))+\n  tm_layout(outer.margins=0, asp=0)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex07_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n:::\n\n\n## Correlation Analysis\n\nBefore we perform cluster analysis, it is important for us to ensure that the cluster variables are not highly correlated.\n\nIn this section, you will learn how to use corrplot.mixed() function of corrplot package to visualise and analyse the correlation of the input variables.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncluster_vars.cor = cor(ict_derived[,12:17])\ncorrplot.mixed(cluster_vars.cor,\n         lower = \"ellipse\", \n               upper = \"number\",\n               tl.pos = \"lt\",\n               diag = \"l\",\n               tl.col = \"black\")\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex07_files/figure-html/unnamed-chunk-12-1.png){width=672}\n:::\n:::\n\n\nThe correlation plot above shows that COMPUTER_PR and INTERNET_PR are highly correlated. This suggest that only one of them should be used in the cluster analysis instead of both.\n\n## Hierarchy Cluster Analysis\n\nIn this section, we will perform hierarchical cluster analysis to segment the townships in Shan State into different zones based on the derived ICT measures. The analysis consists of four major steps:\n\n### Extracting clustering variables\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncluster_vars <- shan_sf %>%\n  st_set_geometry(NULL) %>%\n  select(\"TS.x\", \"RADIO_PR\", \"TV_PR\", \"LLPHONE_PR\", \"MPHONE_PR\", \"COMPUTER_PR\")\nhead(cluster_vars,10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n        TS.x RADIO_PR    TV_PR LLPHONE_PR MPHONE_PR COMPUTER_PR\n1    Mongmit 286.1852 554.1313   35.30618  260.6944    12.15939\n2    Pindaya 417.4647 505.1300   19.83584  162.3917    12.88190\n3    Ywangan 484.5215 260.5734   11.93591  120.2856     4.41465\n4   Pinlaung 231.6499 541.7189   28.54454  249.4903    13.76255\n5     Mabein 449.4903 708.6423   72.75255  392.6089    16.45042\n6      Kalaw 280.7624 611.6204   42.06478  408.7951    29.63160\n7      Pekon 318.6118 535.8494   39.83270  214.8476    18.97032\n8   Lawksawk 387.1017 630.0035   31.51366  320.5686    21.76677\n9  Nawnghkio 349.3359 547.9456   38.44960  323.0201    15.76465\n10   Kyaukme 210.9548 601.1773   39.58267  372.4930    30.94709\n```\n:::\n:::\n\n\nNotice that the final clustering variables list does not include variable INTERNET_PR because it is highly correlated with variable COMPUTER_PR.\n\nNext, we need to change the rows by township name instead of row number by using the code chunk below\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrow.names(cluster_vars) <- cluster_vars$\"TS.x\"\nhead(cluster_vars,10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n               TS.x RADIO_PR    TV_PR LLPHONE_PR MPHONE_PR COMPUTER_PR\nMongmit     Mongmit 286.1852 554.1313   35.30618  260.6944    12.15939\nPindaya     Pindaya 417.4647 505.1300   19.83584  162.3917    12.88190\nYwangan     Ywangan 484.5215 260.5734   11.93591  120.2856     4.41465\nPinlaung   Pinlaung 231.6499 541.7189   28.54454  249.4903    13.76255\nMabein       Mabein 449.4903 708.6423   72.75255  392.6089    16.45042\nKalaw         Kalaw 280.7624 611.6204   42.06478  408.7951    29.63160\nPekon         Pekon 318.6118 535.8494   39.83270  214.8476    18.97032\nLawksawk   Lawksawk 387.1017 630.0035   31.51366  320.5686    21.76677\nNawnghkio Nawnghkio 349.3359 547.9456   38.44960  323.0201    15.76465\nKyaukme     Kyaukme 210.9548 601.1773   39.58267  372.4930    30.94709\n```\n:::\n:::\n\n\nNotice that the row number has been replaced into the township name.\n\nNow, we will delete the TS.x field by using the code chunk below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshan_ict <- select(cluster_vars, c(2:6))\nhead(shan_ict, 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n          RADIO_PR    TV_PR LLPHONE_PR MPHONE_PR COMPUTER_PR\nMongmit   286.1852 554.1313   35.30618  260.6944    12.15939\nPindaya   417.4647 505.1300   19.83584  162.3917    12.88190\nYwangan   484.5215 260.5734   11.93591  120.2856     4.41465\nPinlaung  231.6499 541.7189   28.54454  249.4903    13.76255\nMabein    449.4903 708.6423   72.75255  392.6089    16.45042\nKalaw     280.7624 611.6204   42.06478  408.7951    29.63160\nPekon     318.6118 535.8494   39.83270  214.8476    18.97032\nLawksawk  387.1017 630.0035   31.51366  320.5686    21.76677\nNawnghkio 349.3359 547.9456   38.44960  323.0201    15.76465\nKyaukme   210.9548 601.1773   39.58267  372.4930    30.94709\n```\n:::\n:::\n\n\n### Data Standardisation\n\nIn general, multiple variables will be used in cluster analysis. It is not unusual their values range are different. In order to avoid the cluster analysis result is baised to clustering variables with large values, it is useful to standardise the input variables before performing cluster analysis.\n\n#### **Min-Max standardisation**\n\nIn the code chunk below, *normalize()* of [*heatmaply*](https://cran.r-project.org/web/packages/heatmaply/) package is used to stadardisation the clustering variables by using Min-Max method. The *summary()* is then used to display the summary statistics of the standardised clustering variables.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshan_ict.std <- normalize(shan_ict)\nsummary(shan_ict.std)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    RADIO_PR          TV_PR          LLPHONE_PR       MPHONE_PR     \n Min.   :0.0000   Min.   :0.0000   Min.   :0.0000   Min.   :0.0000  \n 1st Qu.:0.2544   1st Qu.:0.4600   1st Qu.:0.1123   1st Qu.:0.2199  \n Median :0.4097   Median :0.5523   Median :0.1948   Median :0.3846  \n Mean   :0.4199   Mean   :0.5416   Mean   :0.2703   Mean   :0.3972  \n 3rd Qu.:0.5330   3rd Qu.:0.6750   3rd Qu.:0.3746   3rd Qu.:0.5608  \n Max.   :1.0000   Max.   :1.0000   Max.   :1.0000   Max.   :1.0000  \n  COMPUTER_PR     \n Min.   :0.00000  \n 1st Qu.:0.09598  \n Median :0.17607  \n Mean   :0.23692  \n 3rd Qu.:0.29868  \n Max.   :1.00000  \n```\n:::\n:::\n\n\nNotice that the values range of the Min-max standardised clustering variables are 0-1 now.\n\n#### Z-score standardisation\n\nZ-score standardisation can be performed easily by using scale() of Base R. The code chunk below will be used to stadardisation the clustering variables by using Z-score method.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshan_ict.z <- scale(shan_ict)\ndescribe(shan_ict.z)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n            vars  n mean sd median trimmed  mad   min  max range  skew kurtosis\nRADIO_PR       1 55    0  1  -0.04   -0.06 0.94 -1.85 2.55  4.40  0.48    -0.27\nTV_PR          2 55    0  1   0.05    0.04 0.78 -2.47 2.09  4.56 -0.38    -0.23\nLLPHONE_PR     3 55    0  1  -0.33   -0.15 0.68 -1.19 3.20  4.39  1.37     1.49\nMPHONE_PR      4 55    0  1  -0.05   -0.06 1.01 -1.58 2.40  3.98  0.48    -0.34\nCOMPUTER_PR    5 55    0  1  -0.26   -0.18 0.64 -1.03 3.31  4.34  1.80     2.96\n              se\nRADIO_PR    0.13\nTV_PR       0.13\nLLPHONE_PR  0.13\nMPHONE_PR   0.13\nCOMPUTER_PR 0.13\n```\n:::\n:::\n\n\nNotice the mean and standard deviation of the Z-score standardised clustering variables are 0 and 1 respectively.\n\n**Note:** [*describe()*](https://www.rdocumentation.org/packages/Hmisc/versions/4.4-0/topics/describe) of [**psych**](https://cran.r-project.org/web/packages/psych/) package is used here instead of *summary()* of Base R because the earlier provides standard deviation.\n\n***Warning: Z-score standardisation method should only be used if we would assume all variables come from some normal distribution.***\n\n#### **Visualising the standardised clustering variables**\n\nBeside reviewing the summary statistics of the standardised clustering variables, it is also a good practice to visualise their distribution graphical.\n\nThe code chunk below plot the scaled *Radio_PR* field.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nr <- ggplot(data=ict_derived, \n             aes(x= `RADIO_PR`)) +\n  geom_histogram(bins=20, \n                 color=\"black\", \n                 fill=\"light blue\") +\n  ggtitle(\"Raw values without standardisation\")\n\nshan_ict_s_df <- as.data.frame(shan_ict.std)\ns <- ggplot(data=shan_ict_s_df, \n       aes(x=`RADIO_PR`)) +\n  geom_histogram(bins=20, \n                 color=\"black\", \n                 fill=\"light blue\") +\n  ggtitle(\"Min-Max Standardisation\")\n\nshan_ict_z_df <- as.data.frame(shan_ict.z)\nz <- ggplot(data=shan_ict_z_df, \n       aes(x=`RADIO_PR`)) +\n  geom_histogram(bins=20, \n                 color=\"black\", \n                 fill=\"light blue\") +\n  ggtitle(\"Z-score Standardisation\")\n\nggarrange(r, s, z,\n          ncol = 3,\n          nrow = 1)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex07_files/figure-html/unnamed-chunk-18-1.png){width=768}\n:::\n:::\n\n\nIt looks like `RADIO_PR` is already normally distributed.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nr <- ggplot(data=ict_derived, \n             aes(x= `RADIO_PR`)) +\n  geom_density(color=\"black\",\n               fill=\"light blue\") +\n  ggtitle(\"Raw values without standardisation\")\n\nshan_ict_s_df <- as.data.frame(shan_ict.std)\ns <- ggplot(data=shan_ict_s_df, \n       aes(x=`RADIO_PR`)) +\n  geom_density(color=\"black\",\n               fill=\"light blue\") +\n  ggtitle(\"Min-Max Standardisation\")\n\nshan_ict_z_df <- as.data.frame(shan_ict.z)\nz <- ggplot(data=shan_ict_z_df, \n       aes(x=`RADIO_PR`)) +\n  geom_density(color=\"black\",\n               fill=\"light blue\") +\n  ggtitle(\"Z-score Standardisation\")\n\nggarrange(r, s, z,\n          ncol = 3,\n          nrow = 1)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex07_files/figure-html/unnamed-chunk-19-1.png){width=768}\n:::\n:::\n\n\n### **Computing proximity matrix**\n\nIn R, many packages provide functions to calculate distance matrix. We will compute the proximity matrix by using [*dist()*](https://stat.ethz.ch/R-manual/R-devel/library/stats/html/dist.html) of R.\n\n*dist()* supports six distance proximity calculations, they are: **euclidean, maximum, manhattan, canberra, binary and minkowski**. The default is *euclidean* proximity matrix.\n\nThe code chunk below is used to compute the proximity matrix using *euclidean* method.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nproxmat <- dist(shan_ict, method = 'euclidean')\n```\n:::\n\n\nThe code chunk below can then be used to list the content of *proxmat* for visual inspection.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nproxmat\n```\n:::\n\n\n### **Computing hierarchical clustering**\n\nIn R, there are several packages provide hierarchical clustering function. In this hands-on exercise, [*hclust()*](https://stat.ethz.ch/R-manual/R-devel/library/stats/html/hclust.html) of R stats will be used.\n\n*hclust()* employed agglomeration method to compute the cluster. Eight clustering algorithms are supported, they are: ward.D, ward.D2, single, complete, average(UPGMA), mcquitty(WPGMA), median(WPGMC) and centroid(UPGMC).\n\nThe code chunk below performs hierarchical cluster analysis using ward.D method. The hierarchical clustering output is stored in an object of class **hclust** which describes the tree produced by the clustering process.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhclust_ward <- hclust(proxmat, method = 'ward.D')\n```\n:::\n\n\nWe can then plot the tree by using *plot()* of R Graphics as shown in the code chunk below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(hclust_ward, cex = 0.6)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex07_files/figure-html/unnamed-chunk-23-1.png){width=672}\n:::\n:::\n\n\n### **Selecting the optimal clustering algorithm**\n\nOne of the challenge in performing hierarchical clustering is to identify stronger clustering structures. The issue can be solved by using use [*agnes()*](https://www.rdocumentation.org/packages/cluster/versions/2.1.0/topics/agnes) function of [**cluster**](https://cran.r-project.org/web/packages/cluster/) package. It functions like *hclus()*, however, with the *agnes()* function you can also get the agglomerative coefficient, which measures the amount of clustering structure found (values closer to 1 suggest strong clustering structure).\n\nThe code chunk below will be used to compute the agglomerative coefficients of all hierarchical clustering algorithms.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nm <- c( \"average\", \"single\", \"complete\", \"ward\")\nnames(m) <- c( \"average\", \"single\", \"complete\", \"ward\")\n\nac <- function(x) {\n  agnes(shan_ict, method = x)$ac\n}\n\nmap_dbl(m, ac)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  average    single  complete      ward \n0.8131144 0.6628705 0.8950702 0.9427730 \n```\n:::\n:::\n\n\nWith reference to the output above, we can see that Ward’s method provides the strongest clustering structure among the four methods assessed. Hence, in the subsequent analysis, only Ward’s method will be used.\n\n### **Determining Optimal Clusters**\n\nAnother technical challenge face by data analyst in performing clustering analysis is to determine the optimal clusters to retain.\n\nThere are [three](https://statweb.stanford.edu/~gwalther/gap) commonly used methods to determine the optimal clusters, they are:\n\n-   [Elbow Method](https://en.wikipedia.org/wiki/Elbow_method_(clustering))\n\n-   [Average Silhouette Method](https://www.sciencedirect.com/science/article/pii/0377042787901257?via%3Dihub)\n\n-   [Gap Statistic Method](http://www.web.stanford.edu/~hastie/Papers/gap.pdf)\n\n#### 12.7.9.1 Gap Statistic Method\n\nThe [**gap statistic**](http://www.web.stanford.edu/~hastie/Papers/gap.pdf) compares the total within intra-cluster variation for different values of k with their expected values under null reference distribution of the data. The estimate of the optimal clusters will be value that maximize the gap statistic (i.e., that yields the largest gap statistic). This means that the clustering structure is far away from the random uniform distribution of points.\n\nTo compute the gap statistic, [*clusGap()*](https://www.rdocumentation.org/packages/cluster/versions/2.1.0/topics/clusGap) of [**cluster**](https://cran.r-project.org/web/packages/cluster/) package will be used.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(12345)\ngap_stat <- clusGap(shan_ict, \n                    FUN = hcut, \n                    nstart = 25, \n                    K.max = 10, \n                    B = 50)\n# Print the result\nprint(gap_stat, method = \"firstmax\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nClustering Gap statistic [\"clusGap\"] from call:\nclusGap(x = shan_ict, FUNcluster = hcut, K.max = 10, B = 50, nstart = 25)\nB=50 simulated reference sets, k = 1..10; spaceH0=\"scaledPCA\"\n --> Number of clusters (method 'firstmax'): 1\n          logW   E.logW       gap     SE.sim\n [1,] 8.407129 8.680794 0.2736651 0.04460994\n [2,] 8.130029 8.350712 0.2206824 0.03880130\n [3,] 7.992265 8.202550 0.2102844 0.03362652\n [4,] 7.862224 8.080655 0.2184311 0.03784781\n [5,] 7.756461 7.978022 0.2215615 0.03897071\n [6,] 7.665594 7.887777 0.2221833 0.03973087\n [7,] 7.590919 7.806333 0.2154145 0.04054939\n [8,] 7.526680 7.731619 0.2049390 0.04198644\n [9,] 7.458024 7.660795 0.2027705 0.04421874\n[10,] 7.377412 7.593858 0.2164465 0.04540947\n```\n:::\n:::\n\n\nAlso note that the [*hcut*](https://rpkgs.datanovia.com/factoextra/reference/hcut.html) function used is from [**factoextra**](https://rpkgs.datanovia.com/factoextra/) package.\n\nNext, we can visualise the plot by using [*fviz_gap_stat()*](https://rpkgs.datanovia.com/factoextra/reference/fviz_nbclust.html) of [**factoextra**](https://rpkgs.datanovia.com/factoextra/) package.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfviz_gap_stat(gap_stat)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex07_files/figure-html/unnamed-chunk-26-1.png){width=672}\n:::\n:::\n\n\nWith reference to the gap statistic graph above, the recommended number of cluster to retain is 1. However, it is not logical to retain only one cluster. By examine the gap statistic graph, the 6-cluster gives the largest gap statistic and should be the next best cluster to pick.\n\n**Note:** In addition to these commonly used approaches, the [NbClust](https://cran.r-project.org/web/packages/NbClust/) package, published by Charrad et al., 2014, provides 30 indices for determining the relevant number of clusters and proposes to users the best clustering scheme from the different results obtained by varying all combinations of number of clusters, distance measures, and clustering methods.\n\n### **Interpreting the dendrograms**\n\nIn the dendrogram displayed above, each leaf corresponds to one observation. As we move up the tree, observations that are similar to each other are combined into branches, which are themselves fused at a higher height.\n\nThe height of the fusion, provided on the vertical axis, indicates the (dis)similarity between two observations. The higher the height of the fusion, the less similar the observations are. Note that, conclusions about the proximity of two observations can be drawn only based on the height where branches containing those two observations first are fused. We cannot use the proximity of two observations along the horizontal axis as a criteria of their similarity.\n\nIt’s also possible to draw the dendrogram with a border around the selected clusters by using [*rect.hclust()*](https://stat.ethz.ch/R-manual/R-devel/library/stats/html/rect.hclust.html) of R stats. The argument *border* is used to specify the border colors for the rectangles.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(hclust_ward, cex = 0.6)\nrect.hclust(hclust_ward, \n            k = 6, \n            border = 2:5)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex07_files/figure-html/unnamed-chunk-27-1.png){width=672}\n:::\n:::\n\n\n### **Visually-driven hierarchical clustering analysis**\n\nIn this section, we will learn how to perform visually-driven hiearchical clustering analysis by using [*heatmaply*](https://cran.r-project.org/web/packages/heatmaply/) package.\n\nWith **heatmaply**, we are able to build both highly interactive cluster heatmap or static cluster heatmap.\n\n#### Transforming the data frame into a matrix\n\nThe data was loaded into a data frame, but it has to be a data matrix to make your heatmap.\n\nThe code chunk below will be used to transform *shan_ict* data frame into a data matrix.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshan_ict_mat <- data.matrix(shan_ict)\n```\n:::\n\n\n#### Plotting interactive cluster heatmap using *heatmaply()*\n\nIn the code chunk below, the [*heatmaply()*](https://talgalili.github.io/heatmaply/reference/heatmaply.html) of [heatmaply](https://talgalili.github.io/heatmaply/) package is used to build an interactive cluster heatmap.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nheatmaply(normalize(shan_ict_mat),\n          Colv=NA,\n          dist_method = \"euclidean\",\n          hclust_method = \"ward.D\",\n          seriate = \"OLO\",\n          colors = Blues,\n          k_row = 6,\n          margins = c(NA,200,60,NA),\n          fontsize_row = 4,\n          fontsize_col = 5,\n          main=\"Geographic Segmentation of Shan State by ICT indicators\",\n          xlab = \"ICT Indicators\",\n          ylab = \"Townships of Shan State\"\n          )\n```\n:::\n\n\n### **Mapping the clusters formed**\n\nWith closed examination of the dendragram above, we have decided to retain six clusters.\n\n[*cutree()*](https://stat.ethz.ch/R-manual/R-devel/library/stats/html/cutree.html) of R Base will be used in the code chunk below to derive a 6-cluster model.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngroups <- as.factor(cutree(hclust_ward, k=6))\n```\n:::\n\n\nThe output is called *groups*. It is a *list* object.\n\nIn order to visualise the clusters, the *groups* object need to be appended onto *shan_sf* simple feature object.\n\nThe code chunk below form the join in three steps:\n\n-   the *groups* list object will be converted into a matrix;\n\n-   *cbind()* is used to append *groups* matrix onto shan_sf to produce an output simple feature object called `shan_sf_cluster`; and\n\n-   *rename* of **dplyr** package is used to rename *as.matrix.groups* field as *CLUSTER*.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshan_sf_cluster <- cbind(shan_sf, as.matrix(groups)) %>%\n  rename(`CLUSTER`=`as.matrix.groups.`)\n```\n:::\n\n\nNext, *qtm()* of **tmap** package is used to plot the choropleth map showing the cluster formed.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nqtm(shan_sf_cluster, \"CLUSTER\")\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex07_files/figure-html/unnamed-chunk-32-1.png){width=672}\n:::\n:::\n\n\nThe choropleth map above reveals the clusters are very fragmented. The is one of the major limitation when non-spatial clustering algorithm such as hierarchical cluster analysis method is used.\n\n## **Spatially Constrained Clustering: SKATER approach**\n\nIn this section, you will learn how to derive spatially constrained cluster by using [*skater()*](https://r-spatial.github.io/spdep/reference/skater.html) method of [**spdep**](https://r-spatial.github.io/spdep/) package.\n\n### **Converting into SpatialPolygonsDataFrame**\n\nFirst, we need to convert `shan_sf` into SpatialPolygonsDataFrame. This is because SKATER function only support **sp** objects such as SpatialPolygonDataFrame.\n\nThe code chunk below uses [*as_Spatial()*](https://r-spatial.github.io/sf/reference/coerce-methods.html) of **sf** package to convert *shan_sf* into a SpatialPolygonDataFrame called *shan_sp*.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshan_sp <- as_Spatial(shan_sf)\n```\n:::\n\n\n### **Computing Neighbour List**\n\nNext, [poly2nd()](https://r-spatial.github.io/spdep/reference/poly2nb.html) of **spdep** package will be used to compute the neighbours list from polygon list.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshan.nb <- poly2nb(shan_sp)\nsummary(shan.nb)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNeighbour list object:\nNumber of regions: 55 \nNumber of nonzero links: 264 \nPercentage nonzero weights: 8.727273 \nAverage number of links: 4.8 \nLink number distribution:\n\n 2  3  4  5  6  7  8  9 \n 5  9  7 21  4  3  5  1 \n5 least connected regions:\n3 5 7 9 47 with 2 links\n1 most connected region:\n8 with 9 links\n```\n:::\n:::\n\n\nWe can plot the neighbours list on shan_sp by using the code chunk below. Since we now can plot the community area boundaries as well, we plot this graph on top of the map. The first plot command gives the boundaries. This is followed by the plot of the neighbor list object, with coordinates applied to the original SpatialPolygonDataFrame (Shan state township boundaries) to extract the centroids of the polygons. These are used as the nodes for the graph representation. We also set the color to blue and specify add=TRUE to plot the network on top of the boundaries.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(shan_sp, \n     border=grey(0.5))\nplot(shan.nb, \n     coordinates(shan_sp), \n     col=\"blue\", \n     add=TRUE)\n```\n:::\n\n\nNote that if you plot the network first and then the boundaries, some of the areas will be clipped. This is because the plotting area is determined by the characteristics of the first plot. In this example, because the boundary map extends further than the graph, we plot it first.\n\n### **Computing minimum spanning tree**\n\n#### Calculating edge costs\n\nNext, [*nbcosts()*](https://r-spatial.github.io/spdep/reference/nbcosts.html) of **spdep** package is used to compute the cost of each edge. It is the distance between it nodes. This function compute this distance using a data.frame with observations vector in each node.\n\nThe code chunk below is used to compute the cost of each edge.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlcosts <- nbcosts(shan.nb, shan_ict)\n```\n:::\n\n\nFor each observation, this gives the pairwise dissimilarity between its values on the five variables and the values for the neighbouring observation (from the neighbour list). Basically, this is the notion of a generalised weight for a spatial weights matrix.\n\nNext, We will incorporate these costs into a weights object in the same way as we did in the calculation of inverse of distance weights. In other words, we convert the neighbour list to a list weights object by specifying the just computed ***lcosts*** as the weights.\n\nIn order to achieve this, [*nb2listw()*](https://r-spatial.github.io/spdep/reference/nb2listw.html) of **spdep** package is used as shown in the code chunk below.\n\nNote that we specify the *style* as **B** to make sure the cost values are not row-standardized.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshan.w <- nb2listw(shan.nb, \n                   lcosts, \n                   style=\"B\")\nsummary(shan.w)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 55 \nNumber of nonzero links: 264 \nPercentage nonzero weights: 8.727273 \nAverage number of links: 4.8 \nLink number distribution:\n\n 2  3  4  5  6  7  8  9 \n 5  9  7 21  4  3  5  1 \n5 least connected regions:\n3 5 7 9 47 with 2 links\n1 most connected region:\n8 with 9 links\n\nWeights style: B \nWeights constants summary:\n   n   nn       S0       S1        S2\nB 55 3025 76267.65 58260785 522016004\n```\n:::\n:::\n\n\n### **Computing minimum spanning tree**\n\nThe minimum spanning tree is computed by mean of the [*mstree()*](https://r-spatial.github.io/spdep/reference/mstree.html) of **spdep** package as shown in the code chunk below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshan.mst <- mstree(shan.w)\n```\n:::\n\n\nAfter computing the MST, we can check its class and dimension by using the code chunk below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(shan.mst)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"mst\"    \"matrix\"\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndim(shan.mst)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 54  3\n```\n:::\n:::\n\n\nNote that the dimension is 54 and not 55. This is because the minimum spanning tree consists on n-1 edges (links) in order to traverse all the nodes.\n\nWe can display the content of *shan.mst* by using *head()* as shown in the code chunk below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(shan.mst)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2]      [,3]\n[1,]   54   48  47.79331\n[2,]   54   17 109.08506\n[3,]   54   45 127.42203\n[4,]   45   52 146.78891\n[5,]   52   13 110.55197\n[6,]   13   28  92.79567\n```\n:::\n:::\n\n\nThe plot method for the MST include a way to show the observation numbers of the nodes in addition to the edge. As before, we plot this together with the township boundaries. We can see how the initial neighbor list is simplified to just one edge connecting each of the nodes, while passing through all the nodes.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(shan_sp, border=gray(.5))\nplot.mst(shan.mst, \n         coordinates(shan_sp), \n         col=\"blue\", \n         cex.lab=0.7, \n         cex.circles=0.005, \n         add=TRUE)\n```\n:::\n\n\n### **Computing spatially constrained clusters using SKATER method**\n\nThe code chunk below compute the spatially constrained cluster using [*skater()*](https://r-spatial.github.io/spdep/reference/skater.html) of **spdep** package.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclust6 <- spdep::skater(edges = shan.mst[,1:2], \n                 data = shan_ict, \n                 method = \"euclidean\", \n                 ncuts = 5)\n```\n:::\n\n\nThe *skater()* takes three mandatory arguments: - the first two columns of the MST matrix (i.e. not the cost), - the data matrix (to update the costs as units are being grouped), and - the number of cuts. Note: It is set to **one less than the number of clusters**. So, the value specified is **not** the number of clusters, but the number of cuts in the graph, one less than the number of clusters.\n\nThe result of the *skater()* is an object of class **skater**. We can examine its contents by using the code chunk below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(clust6)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nList of 8\n $ groups      : num [1:55] 3 3 6 3 3 3 3 3 3 3 ...\n $ edges.groups:List of 6\n  ..$ :List of 3\n  .. ..$ node: num [1:22] 13 48 54 55 45 37 34 16 25 52 ...\n  .. ..$ edge: num [1:21, 1:3] 48 55 54 37 34 16 45 25 13 13 ...\n  .. ..$ ssw : num 3423\n  ..$ :List of 3\n  .. ..$ node: num [1:18] 47 27 53 38 42 15 41 51 43 32 ...\n  .. ..$ edge: num [1:17, 1:3] 53 15 42 38 41 51 15 27 15 43 ...\n  .. ..$ ssw : num 3759\n  ..$ :List of 3\n  .. ..$ node: num [1:11] 2 6 8 1 36 4 10 9 46 5 ...\n  .. ..$ edge: num [1:10, 1:3] 6 1 8 36 4 6 8 10 10 9 ...\n  .. ..$ ssw : num 1458\n  ..$ :List of 3\n  .. ..$ node: num [1:2] 44 20\n  .. ..$ edge: num [1, 1:3] 44 20 95\n  .. ..$ ssw : num 95\n  ..$ :List of 3\n  .. ..$ node: num 23\n  .. ..$ edge: num[0 , 1:3] \n  .. ..$ ssw : num 0\n  ..$ :List of 3\n  .. ..$ node: num 3\n  .. ..$ edge: num[0 , 1:3] \n  .. ..$ ssw : num 0\n $ not.prune   : NULL\n $ candidates  : int [1:6] 1 2 3 4 5 6\n $ ssto        : num 12613\n $ ssw         : num [1:6] 12613 10977 9962 9540 9123 ...\n $ crit        : num [1:2] 1 Inf\n $ vec.crit    : num [1:55] 1 1 1 1 1 1 1 1 1 1 ...\n - attr(*, \"class\")= chr \"skater\"\n```\n:::\n:::\n\n\nThe most interesting component of this list structure is the groups vector containing the labels of the cluster to which each observation belongs (as before, the label itself is arbitary). This is followed by a detailed summary for each of the clusters in the edges.groups list. Sum of squares measures are given as ssto for the total and ssw to show the effect of each of the cuts on the overall criterion.\n\nWe can check the cluster assignment by using the conde chunk below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nccs6 <- clust6$groups\nccs6\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 3 3 6 3 3 3 3 3 3 3 2 1 1 1 2 1 1 1 2 4 1 2 5 1 1 1 2 1 2 2 1 2 2 1 1 3 1 2\n[39] 2 2 2 2 2 4 1 3 2 1 1 1 2 1 2 1 1\n```\n:::\n:::\n\n\nWe can find out how many observations are in each cluster by means of the table command. Parenthetially, we can also find this as the dimension of each vector in the lists contained in edges.groups. For example, the first list has node with dimension 12, which is also the number of observations in the first cluster.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntable(ccs6)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nccs6\n 1  2  3  4  5  6 \n22 18 11  2  1  1 \n```\n:::\n:::\n\n\nLastly, we can also plot the pruned tree that shows the five clusters on top of the townshop area.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(shan_sp, border=gray(.5))\nplot(clust6, \n     coordinates(shan_sp), \n     cex.lab=.7,\n     groups.colors=c(\"red\",\"green\",\"blue\", \"brown\", \"pink\"),\n     cex.circles=0.005, \n     add=TRUE)\n```\n:::\n\n\n### **Visualising the clusters in choropleth map**\n\nThe code chunk below is used to plot the newly derived clusters by using SKATER method.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngroups_mat <- as.matrix(clust6$groups)\nshan_sf_spatialcluster <- cbind(shan_sf_cluster, as.factor(groups_mat)) %>%\n  rename(`SP_CLUSTER`=`as.factor.groups_mat.`)\nqtm(shan_sf_spatialcluster, \"SP_CLUSTER\")\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex07_files/figure-html/unnamed-chunk-48-1.png){width=672}\n:::\n:::\n\n\nFor easy comparison, it will be better to place both the hierarchical clustering and spatially constrained hierarchical clustering maps next to each other.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhclust.map <- qtm(shan_sf_cluster,\n                  \"CLUSTER\") + \n  tm_borders(alpha = 0.5) \n\nshclust.map <- qtm(shan_sf_spatialcluster,\n                   \"SP_CLUSTER\") + \n  tm_borders(alpha = 0.5) \n\ntmap_arrange(hclust.map, shclust.map,\n             asp=NA, ncol=2)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex07_files/figure-html/unnamed-chunk-49-1.png){width=672}\n:::\n:::\n\n\n## **Spatially Constrained Clustering: ClustGeo Method**\n\nIn this section, you will gain hands-on experience on using functions provided by **ClustGeo** package to perform non-spatially constrained hierarchical cluster analysis and spatially constrained cluster analysis.\n\n### **A short note about ClustGeo package**\n\n[**ClustGeo**](https://cran.r-project.org/web/packages/ClustGeo/) package is an R package specially designed to support the need of performing spatially constrained cluster analysis. More specifically, it provides a Ward-like hierarchical clustering algorithm called `hclustgeo()` including spatial/geographical constraints.\n\nIn the nutshell, the algorithm uses two dissimilarity matrices D0 and D1 along with a mixing parameter alpha, whereby the value of alpha must be a real number between \\[0, 1\\]. D0 can be non-Euclidean and the weights of the observations can be non-uniform. It gives the dissimilarities in the **attribute/clustering variable space**. D1, on the other hand, gives the dissimilarities in the **constraint space**. The criterion minimised at each stage is a convex combination of the homogeneity criterion calculated with D0 and the homogeneity criterion calculated with D1.\n\nThe idea is then to determine a value of alpha which increases the spatial contiguity without deteriorating too much the quality of the solution based on the variables of interest. This need is supported by a function called `choicealpha()`.\n\n### **Ward-like hierarchical clustering: ClustGeo**\n\nClustGeo package provides function called `hclustgeo()` to perform a typical Ward-like hierarchical clustering just like `hclust()` you learned in previous section.\n\nTo perform non-spatially constrained hierarchical clustering, we only need to provide the function a dissimilarity matrix as shown in the code chunk below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnongeo_cluster <- hclustgeo(proxmat)\nplot(nongeo_cluster, cex = 0.5)\nrect.hclust(nongeo_cluster, \n            k = 6, \n            border = 2:5)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex07_files/figure-html/unnamed-chunk-50-1.png){width=672}\n:::\n:::\n\n\nNote that the dissimilarity matrix must be an object of class `dist`, i.e. an object obtained with the function `dist()`. For sample code chunk, please refer to [5.7.6 Computing proximity matrix](https://r4gdsa.netlify.app/chap05#computing-proximity-matrix)\n\n#### Mapping the clusters formed\n\nSimilarly, we can plot the clusters on a categorical area shaded map by using the steps we learned in 5.7.12 Mapping the clusters formed.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngroups <- as.factor(cutree(nongeo_cluster, k=6))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nshan_sf_ngeo_cluster <- cbind(shan_sf, as.matrix(groups)) %>%\n  rename(`CLUSTER` = `as.matrix.groups.`)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nqtm(shan_sf_ngeo_cluster, \"CLUSTER\")\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex07_files/figure-html/unnamed-chunk-53-1.png){width=672}\n:::\n:::\n\n\n### **Spatially Constrained Hierarchical Clustering**\n\nBefore we can performed spatially constrained hierarchical clustering, a spatial distance matrix will be derived by using [`st_distance()`](https://r-spatial.github.io/sf/reference/geos_measures.html) of sf package.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndist <- st_distance(shan_sf, shan_sf)\ndistmat <- as.dist(dist)\n```\n:::\n\n\nNotice that `as.dist()` is used to convert the data frame into matrix.\n\nNext, `choicealpha()` will be used to determine a suitable value for the mixing parameter alpha as shown in the code chunk below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncr <- choicealpha(proxmat, distmat, range.alpha = seq(0, 1, 0.1), K=6, graph = TRUE)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex07_files/figure-html/unnamed-chunk-55-1.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](Hands-on_Ex07_files/figure-html/unnamed-chunk-55-2.png){width=672}\n:::\n:::\n\n\nWith reference to the graphs above, alpha = 0.3 will be used as shown in the code chunk below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclustG <- hclustgeo(proxmat, distmat, alpha = 0.3)\n```\n:::\n\n\nNext, `cutree()` is used to derive the cluster objecct.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngroups <- as.factor(cutree(clustG, k=6))\n```\n:::\n\n\nWe will then join back the group list with *shan_sf* polygon feature data frame by using the code chunk below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshan_sf_Gcluster <- cbind(shan_sf, as.matrix(groups)) %>%\n  rename(`CLUSTER` = `as.matrix.groups.`)\n```\n:::\n\n\nWe can now plot the map of the newly delineated spatially constrained clusters.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nqtm(shan_sf_Gcluster, \"CLUSTER\")\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex07_files/figure-html/unnamed-chunk-59-1.png){width=672}\n:::\n:::\n\n\n## **Visual Interpretation of Clusters**\n\n### **Visualising individual clustering variable**\n\nCode chunk below is used to reveal the distribution of a clustering variable (i.e RADIO_PR) by cluster.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = shan_sf_ngeo_cluster,\n       aes(x = CLUSTER, y = RADIO_PR)) +\n  geom_boxplot()\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex07_files/figure-html/unnamed-chunk-60-1.png){width=672}\n:::\n:::\n\n\nThe boxplot reveals Cluster 3 displays the highest mean Radio Ownership Per Thousand Household. This is followed by Cluster 2, 1, 4, 6 and 5.\n\n### **Multivariate Visualisation**\n\nPast studies shown that parallel coordinate plot can be used to reveal clustering variables by cluster very effectively. In the code chunk below, [`ggparcoord()`](https://ggobi.github.io/ggally/reference/ggparcoord.html) of [**GGally**](https://ggobi.github.io/ggally/) package\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggparcoord(data = shan_sf_ngeo_cluster, \n           columns = c(17:21), \n           scale = \"globalminmax\",\n           alphaLines = 0.2,\n           boxplot = TRUE, \n           title = \"Multiple Parallel Coordinates Plots of ICT Variables by Cluster\") +\n  facet_grid(~ CLUSTER) + \n  theme(axis.text.x = element_text(angle = 30))\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex07_files/figure-html/unnamed-chunk-61-1.png){width=960}\n:::\n:::\n\n\nThe parallel coordinate plot above reveals that households in Cluster 4 townships tend to own the highest number of TV and mobile-phone. On the other hand, households in Cluster 5 tends to own the lowest of all the five ICT.\n\nNote that the `scale` argument of `ggparcoor()` provide several methods to scale the clustering variables. They are:\n\n-   std: univariately, subtract mean and divide by standard deviation.\n\n-   robust: univariately, subtract median and divide by median absolute deviation.\n\n-   uniminmax: univariately, scale so the minimum of the variable is zero, and the maximum is one.\n\n-   globalminmax: no scaling is done; the range of the graphs is defined by the global minimum and the global maximum.\n\n-   center: use uniminmax to standardize vertical height, then center each variable at a value specified by the scaleSummary param.\n\n-   centerObs: use uniminmax to standardize vertical height, then center each variable at the value of the observation specified by the centerObsID param\n\nThere is no one best scaling method to use. You should explore them and select the one that best meet your analysis need.\n\nLast but not least, we can also compute the summary statistics such as mean, median, sd, etc to complement the visual interpretation.\n\nIn the code chunk below, `group_by()` and `summarise()` of dplyr are used to derive mean values of the clustering variables.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshan_sf_ngeo_cluster %>% \n  st_set_geometry(NULL) %>%\n  group_by(CLUSTER) %>%\n  summarise(mean_RADIO_PR = mean(RADIO_PR),\n            mean_TV_PR = mean(TV_PR),\n            mean_LLPHONE_PR = mean(LLPHONE_PR),\n            mean_MPHONE_PR = mean(MPHONE_PR),\n            mean_COMPUTER_PR = mean(COMPUTER_PR))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 6\n  CLUSTER mean_RADIO_PR mean_TV_PR mean_LLPHONE_PR mean_MPHONE_PR\n  <chr>           <dbl>      <dbl>           <dbl>          <dbl>\n1 1               221.        521.            44.2           246.\n2 2               237.        402.            23.9           134.\n3 3               300.        611.            52.2           392.\n4 4               196.        744.            99.0           651.\n5 5               124.        224.            38.0           132.\n6 6                98.6       499.            74.5           468.\n# ℹ 1 more variable: mean_COMPUTER_PR <dbl>\n```\n:::\n:::\n",
    "supporting": [
      "Hands-on_Ex07_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}