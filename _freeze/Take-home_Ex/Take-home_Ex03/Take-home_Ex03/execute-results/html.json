{
  "hash": "b99af1ddf87e4eaebadb6a65964e6cec",
  "result": {
    "markdown": "---\ntitle: \"Take-home Exercise 3: Prototyping Modules for Geospatial Analytics Shiny Application\"\nformat: \n  html:\n    code-summary: \"Show code\"\n    toc-depth: 4\n    code-overflow: \"scroll\"\n    code-fold: true\nauthor: \"Alexander Vincent Lewi\"\ndate: \"24 March 2024\"\nexecute: \n  freeze: true\n  message: false\n  warning: false\n---\n\n\n## Overview\n\n## Getting Started\n\n### The data\n\n#### Geospatial Data\n\n-   [Jakarta Shapefile](https://www.indonesia-geospasial.com/2020/01/shp-rbi-provinsi-dki-jakarta-perwilayah.html)\n\n    -   This dataset is taken from the Indonesia Geospasial website\n\n    -   It is divided based on the different administrative cities in Jakarta, consisting of the POIs available in each city.\n\n#### Aspatial Data\n\n-   [Mamikos Dataset](https://mamikos.com/)\n\n    -   This dataset is scraped from Mamikos website\n    -   The dataset consists of rental units in Jakarta and the facilities provided in each rental unit\n\n-   [School and University dataset in Jakarta](https://referensi.data.kemdikbud.go.id/pendidikan/dikti/010000/1)\n\n    -   This dataset is scraped from Indonesia's Ministry of Education and Culture (Kemendikbud) website\n\n### Packages\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(car, olsrr, corrplot, ggpubr, sf, spdep, GWmodel, tmap, tidyverse, gtsummary)\n```\n:::\n\n\n## Data Wrangling\n\n### Jakarta Map\n\nFirst, we need to combine the shapefiles of each administrative 'desa' in Jakarta to create a map of Jakarta.\n\n\n::: {.cell}\n\n```{.r .cell-code}\njakbar_adm_desa <- st_read(dsn = \"data/geospatial/Jakarta/KOTA_JAKARTA_BARAT\", layer = \"ADMINISTRASIDESA_AR_25K\")\njakbar_adm_desa <- st_zm(jakbar_adm_desa, zm=\"Z\")\njakbar_adm_desa_sf <- jakbar_adm_desa |> st_transform(crs = 4326)\n\njakpus_adm_desa <- st_read(dsn = \"data/geospatial/Jakarta/KOTA_JAKARTA_PUSAT\", layer = \"ADMINISTRASIDESA_AR_25K\")\njakpus_adm_desa <- st_zm(jakpus_adm_desa, zm=\"Z\")\njakpus_adm_desa_sf <- jakpus_adm_desa |> st_transform(crs = 4326)\n\njaksel_adm_desa <- st_read(dsn = \"data/geospatial/Jakarta/KOTA_JAKARTA_SELATAN\", layer = \"ADMINISTRASIDESA_AR_25K\")\njaksel_adm_desa <- st_zm(jaksel_adm_desa, zm=\"Z\")\njaksel_adm_desa_sf <- jaksel_adm_desa |> st_transform(crs = 4326)\n\njakut_adm_desa <- st_read(dsn = \"data/geospatial/Jakarta/KOTA_JAKARTA_UTARA\", layer = \"ADMINISTRASIDESA_AR_25K\")\njakut_adm_desa <- st_zm(jakut_adm_desa, zm=\"Z\")\njakut_adm_desa_sf <- jakut_adm_desa |> st_transform(crs = 4326)\n\njaktim_adm_desa <- st_read(dsn = \"data/geospatial/Jakarta/KOTA_JAKARTA_TIMUR\", layer = \"ADMINISTRASIDESA_AR_25K\")\njaktim_adm_desa <- st_zm(jaktim_adm_desa, zm=\"Z\")\njaktim_adm_desa_sf <- jaktim_adm_desa |> st_transform(crs = 4326)\njaktim_adm_desa_sf <- st_make_valid(jaktim_adm_desa_sf)\n```\n:::\n\n\nTo combine the shapefiles, we use the `rbind` function. Then, we save the shapefile as an shp file so that we can call it.\n\n\n::: {.cell}\n\n```{.r .cell-code}\njakarta_sf <- rbind(jakbar_adm_desa_sf,\n                    jakpus_adm_desa_sf,\n                    jaksel_adm_desa_sf,\n                    jakut_adm_desa_sf,\n                    jaktim_adm_desa_sf)\n\nwrite_rds(jakarta_sf, \"data/rds/jakarta_sf.rds\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\njakarta_sf <- read_rds(\"data/rds/jakarta_sf.rds\")\nqtm(jakarta_sf)\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex03_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n:::\n\n\n### Mamikos\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmamikos <- read_csv(\"data/aspatial/mamikos.csv\")\n```\n:::\n\n\n#### Selecting Relevant Columns\n\nSome of the important columns in the dataset include:\n\n-   **\\_id**: The unique identifier for each unit.\n\n-   **price_monthly**: The monthly price of the unit.\n\n-   **latitude**: The latitude of the unit.\n\n-   **longitude**: The longitude of the unit.\n\n-   **gender**: The gender preference for potential tenants (mixed, male, or female).\n\n-   **size** : The size of the accommodation.\n\n-   **fac_room**: Facilities available within the room itself (e.g., air conditioning, bed, wardrobe, etc.).\n\n-   **fac_share**: Shared facilities that tenants can use (e.g., kitchen, living room).\n\n-   **fac_bath**: Bathroom facilities (private or shared, including features like hot water).\n\n-   **fac_near**: Facilities or points of interest near the accommodation (e.g., supermarket, campus, public transport).\n\n-   **fac_park**: Parking facilities (availability and type, such as for cars or motorbikes).\n\n-   **kos_rule**: The rules or regulations tenants must follow (e.g., no pets, curfew times).\n\n-   **fac_price**: Additional costs for facilities (e.g., laundry fees, cleaning service fees).\n\n-   **building_year**: The year the building was constructed or established.\n\n-   **number_success_owner_trx**: The number of successful transactions the owner has completed on the platform.\n\n-   **number_success_kos_trx**: The number of successful transactions for this specific listing.\n\nFor the purpose of this prototyping, we will only focus on **price_monthly**, **latitude**, **longitude**, **gender**, **size**, and **building_year**.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmamikos <- mamikos |> \n  select(`_id`, price_monthly, latitude, longitude, gender, size, building_year)\n```\n:::\n\n\n#### Reformatting the Size Column\n\nThe **size** column is currently a character column with inconsistent formats. We will convert this to a numeric column representing the total area. To do that, we will create a custom function to calculate the area based on the different formats found in the dataset.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncalculate_area <-  function(size_string) {\n  # Deal with potential NA values upfront\n  if (is.na(size_string)) {\n    return(NA)\n  }\n  \n  # lowercase the string for easier matching\n  size <- tolower(size_string)\n  \n  # Replace all non-standard x's and commas with a standard format\n  size <- gsub(\"×\", \"x\", size)\n  \n  # Normalize decimal separator from comma to dot and remove spaces\n  size <- gsub(\",\\\\s*\", \".\", size) # Changes \"2,5 x 3\" to \"2.5 x 3\"\n  \n  # Remove any \"m2\" text, assuming that the presence of 'x' or '×' already denotes area calculation\n  size <- gsub(\"m2\", \"\", size, ignore.case = TRUE)\n  \n  # Extract numeric values\n  numbers <- as.numeric(unlist(str_extract_all(size, \"[0-9.]+\")))\n  \n  # Simple heuristic: if more than 2 numbers, take first two assuming additional info is irrelevant\n  if (length(numbers) > 2) {\n    numbers <- numbers[1:2]\n  }\n  \n  # Calculate the area; if it's a single number, assume it's already the area\n  area <- if (length(numbers) == 2) prod(numbers) else if (length(numbers) == 1) numbers else 0\n  \n  if (area > 10000) {\n    area <- area / 10000\n  } else if (area > 100) {\n    area <- area / 100\n  } else if (area == 0 ) {\n    area <- NA\n  }\n  \n  return (area)\n}\n```\n:::\n\n\nWe can now apply this function to the **size** column to calculate the area in square meters.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmamikos <- mamikos |>\n  mutate(size = sapply(size, calculate_area))\n```\n:::\n\n\n#### Removing Invalid Building Years\n\nSome entries in the **building_year** column have a value of 0, which is likely an error or missing data. We will remove these entries from the dataset.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmamikos <- mamikos |>\n  filter(building_year > 0)\n```\n:::\n\n\n#### Handling Missing Values\n\nFinally, we will remove any rows with missing values in the dataset.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmamikos <- mamikos |> \n  drop_na()\n```\n:::\n\n\n#### Converting to Simple Features\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmamikos_sf <- st_as_sf(mamikos, coords = c(\"longitude\", \"latitude\"), crs=4326)\n```\n:::\n\n\n#### Filtering Mamikos Units in Jakarta\n\nAlthough the dataset is scraped specifially for Jakarta, the website still recommends units outside of Jakarta. We will filter the dataset to only include units within Jakarta.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmamikos_sf <- mamikos_sf |> \n  st_intersection(jakarta_sf) |> \n  select(X_id, price_monthly, gender, size, building_year, geometry)\n\nwrite_rds(mamikos_sf, \"data/rds/mamikos_sf.rds\")\n```\n:::\n\n::: {.cell}\n\n:::\n\n\n### POIs\n\nPOIs are points of interest that are relevant to potential tenants. In this prototype, we will focus on the following POIs:\n\n-   **Airport**: Soekarno-Hatta International Airport and Halim Perdanakusuma International Airport.\n\n-   **Stasiun Kereta Api**: Train stations.\n\n-   **Kesehatan**: Health facilities.\n\n-   **Pendidikan**: Schools and universities.\n\n-   **Kantor Pos**: Post offices.\n\n-   **Sarana Ibadah**: Places of worship.\n\nBefore we can calculate the distance between each Mamikos unit and the Points of Interest (POIs), we need to create a helper `remove_unit()` to remove the unit string generated by the function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nremove_unit <- function(x) {\n  as.numeric(str_sub(x, 1, -4))\n}\n```\n:::\n\n\n#### Airport\n\nSince the airport shapefile in the Jakarta dataset are all empty, we will manually input the coordinates of the two airports in Jakarta.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nname <- c(\"Soekarno-Hatta International Airport\", \"Halim Perdanakusuma International Airport\")\nlat <- c(-6.123335553024524, -6.265380365738848)\nlon <- c(106.65980883674271, 106.8851665557591)\nREMARK <- c(\"AIRPORT\", \"AIRPORT\")\n\nairport <- data.frame(REMARK, lat, lon) |> st_as_sf(coords = c(\"lon\", \"lat\"), crs = 4326)\n```\n:::\n\n\n#### Stasiun Kereta Api / Train Stations\n\nWe will read the shapefiles of the train stations in each administrative 'desa' in Jakarta and combine them into one.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstasiunka_jakbar <- st_read(dsn = \"data/geospatial/Jakarta/KOTA_JAKARTA_BARAT\", layer = \"STASIUNKA_PT_25K\")\nstasiunka_jakbar_sf <- stasiunka_jakbar |> st_transform(crs = 4326) |> select(REMARK, geometry)\n\nstasiunka_jakpus <- st_read(dsn = \"data/geospatial/Jakarta/KOTA_JAKARTA_PUSAT\", layer = \"STASIUNKA_PT_25K\")\nstasiunka_jakpus_sf <- stasiunka_jakpus |> st_transform(crs = 4326) |> select(REMARK, geometry)\n\nstasiunka_jaksel <- st_read(dsn = \"data/geospatial/Jakarta/KOTA_JAKARTA_SELATAN\", layer = \"STASIUNKA_PT_25K\")\nstasiunka_jaksel_sf <- stasiunka_jaksel |> st_transform(crs = 4326) |> select(REMARK, geometry)\n\nstasiunka_jakut <- st_read(dsn = \"data/geospatial/Jakarta/KOTA_JAKARTA_UTARA\", layer = \"STASIUNKA_PT_25K\")\nstasiunka_jakut_sf <- stasiunka_jakut |> st_transform(crs = 4326) |> select(REMARK, geometry)\n\nstasiunka_jaktim <- st_read(dsn = \"data/geospatial/Jakarta/KOTA_JAKARTA_TIMUR\", layer = \"STASIUNKA_PT_25K\")\nstasiunka_jaktim_sf <- stasiunka_jaktim |> st_transform(crs = 4326) |> select(REMARK, geometry)\n\nstasiunka <- rbind(stasiunka_jakbar_sf, stasiunka_jakpus_sf, stasiunka_jaksel_sf, stasiunka_jakut_sf, stasiunka_jaktim_sf) |> mutate(REMARK = \"STASIUNKA\") |> st_zm(zm=\"Z\")\n```\n:::\n\n\nCALCULATING MEDIAN DISTANCE BETWEEN STASIUNKA\n\nNow we need to count the number of POIs within a certain distance from the rental units. We will use the median distance as the threshold.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstasiunka_dist <- st_distance(stasiunka)\nstasiunka_dist <- data.frame(stasiunka_dist)\nstasiunka_dist <- sapply(stasiunka_dist, remove_unit)\ncolnames(stasiunka_dist) <- stasiunka$REMARK\nrownames(stasiunka_dist) <- stasiunka$REMARK\nstasiunka_dist_med <- apply(stasiunka_dist, 1, median, na.rm = TRUE)\nstasiunka_dist_med <- data.frame(stasiunka_dist_med)\nstasiunka_med <- median(stasiunka_dist_med$stasiunka_dist_med)\n```\n:::\n\n\n#### Kesehatan / Health Facilities\n\nNext, we will read the shapefiles of the health facilities in each administrative 'desa' in Jakarta and combine them into one.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nkesehatan_jakbar <- st_read(dsn = \"data/geospatial/Jakarta/KOTA_JAKARTA_BARAT\", layer = \"KESEHATAN_PT_25K\")\nkesehatan_jakbar_sf <- kesehatan_jakbar |> st_transform(crs = 4326) |> select(REMARK, geometry)\n\nkesehatan_jakpus <- st_read(dsn = \"data/geospatial/Jakarta/KOTA_JAKARTA_PUSAT\", layer = \"KESEHATAN_PT_25K\")\nkesehatan_jakpus_sf <- kesehatan_jakpus |> st_transform(crs = 4326) |> select(REMARK, geometry)\n\nkesehatan_jaksel <- st_read(dsn = \"data/geospatial/Jakarta/KOTA_JAKARTA_SELATAN\", layer = \"KESEHATAN_PT_25K\")\nkesehatan_jaksel_sf <- kesehatan_jaksel |> st_transform(crs = 4326) |> select(REMARK, geometry)\n\nkesehatan_jakut <- st_read(dsn = \"data/geospatial/Jakarta/KOTA_JAKARTA_UTARA\", layer = \"KESEHATAN_PT_25K\")\nkesehatan_jakut_sf <- kesehatan_jakut |> st_transform(crs = 4326) |> select(REMARK, geometry)\n\nkesehatan_jaktim <- st_read(dsn = \"data/geospatial/Jakarta/KOTA_JAKARTA_TIMUR\", layer = \"KESEHATAN_PT_25K\")\nkesehatan_jaktim_sf <- kesehatan_jaktim |> st_transform(crs = 4326) |> select(REMARK, geometry)\n\nkesehatan <- rbind(kesehatan_jakbar_sf, kesehatan_jakpus_sf, kesehatan_jaksel_sf, kesehatan_jakut_sf, kesehatan_jaktim_sf) |> mutate(REMARK = \"KESEHATAN\") |> st_zm(zm=\"Z\")\n```\n:::\n\n\nCALCULATING MEDIAN DISTANCE BETWEEN KESEHATAN\n\nSame as the STASIUNKA POI, we will calculate the median distance between each health facility in Jakarta, which will be used when we are counting the number of POIs within a certain distance from the rental units.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nkesehatan_dist <- st_distance(kesehatan)\nkesehatan_dist <- data.frame(kesehatan_dist)\nkesehatan_dist <- sapply(kesehatan_dist, remove_unit)\ncolnames(kesehatan_dist) <- kesehatan$REMARK\nrownames(kesehatan_dist) <- kesehatan$REMARK\nkesehatan_dist_med <- apply(kesehatan_dist, 1, median, na.rm = TRUE)\nkesehatan_dist_med <- data.frame(kesehatan_dist_med)\nkesehatan_med <- median(kesehatan_dist_med$kesehatan_dist_med)\n```\n:::\n\n\n#### Pendidikan / Schools and Universities\n\n\n::: {.cell}\n\n```{.r .cell-code}\npendidikan_jakbar <- st_read(dsn = \"data/Jakarta/KOTA_JAKARTA_BARAT\", layer = \"PENDIDIKAN_PT_25K\")\npendidikan_jakbar_sf <- pendidikan_jakbar |> st_transform(crs = 4326) |> select(REMARK, geometry)\n\npendidikan_jakpus <- st_read(dsn = \"data/Jakarta/KOTA_JAKARTA_PUSAT\", layer = \"PENDIDIKAN_PT_25K\")\npendidikan_jakpus_sf <- pendidikan_jakpus |> st_transform(crs = 4326) |> select(REMARK, geometry)\n\npendidikan_jaksel <- st_read(dsn = \"data/Jakarta/KOTA_JAKARTA_SELATAN\", layer = \"PENDIDIKAN_PT_25K\")\npendidikan_jaksel_sf <- pendidikan_jaksel |> st_transform(crs = 4326) |> select(REMARK, geometry)\n\npendidikan_jakut <- st_read(dsn = \"data/Jakarta/KOTA_JAKARTA_UTARA\", layer = \"PENDIDIKAN_PT_25K\")\npendidikan_jakut_sf <- pendidikan_jakut |> st_transform(crs = 4326) |> select(REMARK, geometry)\n\npendidikan_jaktim <- st_read(dsn = \"data/Jakarta/KOTA_JAKARTA_TIMUR\", layer = \"PENDIDIKAN_PT_25K\")\npendidikan_jaktim_sf <- pendidikan_jaktim |> st_transform(crs = 4326) |> select(REMARK, geometry)\n\npendidikan <- rbind(pendidikan_jakbar_sf, pendidikan_jakpus_sf, pendidikan_jaksel_sf, pendidikan_jakut_sf, pendidikan_jaktim_sf) |> mutate(REMARK = \"PENDIDIKAN\") |> st_zm(zm=\"Z\")\n```\n:::\n\n\nCALCULATING MEDIAN DISTANCE BETWEEN PENDIDIKAN\n\n\n::: {.cell}\n\n```{.r .cell-code}\npendidikan_dist <- st_distance(pendidikan)\npendidikan_dist <- data.frame(pendidikan_dist)\npendidikan_dist <- sapply(pendidikan_dist, rm_unit)\ncolnames(pendidikan_dist) <- pendidikan$REMARK\nrownames(pendidikan_dist) <- pendidikan$REMARK\npendidikan_dist_med <- apply(pendidikan_dist, 1, median, na.rm = TRUE)\npendidikan_dist_med <- data.frame(pendidikan_dist_med)\npendidikan_med <- median(pendidikan_dist_med$pendidikan_dist_med)\n```\n:::\n\n\n#### Kantor Pos / Post Offices\n\nWe will also read the shapefiles of the post offices in each administrative 'desa' in Jakarta and combine them into one.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nkantorpos_jakbar <- st_read(dsn = \"data/geospatial/Jakarta/KOTA_JAKARTA_BARAT\", layer = \"KANTORPOS_PT_25K\")\nkantorpos_jakbar_sf <- kantorpos_jakbar |> st_transform(crs = 4326) |> select(REMARK, geometry)\n\nkantorpos_jakpus <- st_read(dsn = \"data/geospatial/Jakarta/KOTA_JAKARTA_PUSAT\", layer = \"KANTORPOS_PT_25K\")\nkantorpos_jakpus_sf <- kantorpos_jakpus |> st_transform(crs = 4326) |> select(REMARK, geometry)\n\nkantorpos_jaksel <- st_read(dsn = \"data/geospatial/Jakarta/KOTA_JAKARTA_SELATAN\", layer = \"KANTORPOS_PT_25K\")\nkantorpos_jaksel_sf <- kantorpos_jaksel |> st_transform(crs = 4326) |> select(REMARK, geometry)\n\nkantorpos_jakut <- st_read(dsn = \"data/geospatial/Jakarta/KOTA_JAKARTA_UTARA\", layer = \"KANTORPOS_PT_25K\")\nkantorpos_jakut_sf <- kantorpos_jakut |> st_transform(crs = 4326) |> select(REMARK, geometry)\n\nkantorpos_jaktim <- st_read(dsn = \"data/geospatial/Jakarta/KOTA_JAKARTA_TIMUR\", layer = \"KANTORPOS_PT_25K\")\nkantorpos_jaktim_sf <- kantorpos_jaktim |> st_transform(crs = 4326) |> select(REMARK, geometry)\n\nkantorpos <- rbind(kantorpos_jakbar_sf, kantorpos_jakpus_sf, kantorpos_jaksel_sf, kantorpos_jakut_sf, kantorpos_jaktim_sf) |> mutate(REMARK = \"KANTORPOS\") |> st_zm(zm=\"Z\")\n```\n:::\n\n\nCALCULATING MEDIAN DISTANCE BETWEEN KANTORPOS\n\nWe will calculate the median distance between each post office in Jakarta, which will be used when we are counting the number of POIs within a certain distance from the rental units.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nkantorpos_dist <- st_distance(kantorpos)\nkantorpos_dist <- data.frame(kantorpos_dist)\nkantorpos_dist <- sapply(kantorpos_dist, remove_unit)\ncolnames(kantorpos_dist) <- kantorpos$REMARK\nrownames(kantorpos_dist) <- kantorpos$REMARK\nkantorpos_dist_med <- apply(kantorpos_dist, 1, median, na.rm = TRUE)\nkantorpos_dist_med <- data.frame(kantorpos_dist_med)\nkantorpos_med <- median(kantorpos_dist_med$kantorpos_dist_med)\n```\n:::\n\n\n#### Sarana Ibadah / Places of Worship\n\nThis time, we will read the shapefiles of the places of worship in each administrative 'desa' in Jakarta and combine them into one.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsaranaibadah_jakbar <- st_read(dsn = \"data/geospatial/Jakarta/KOTA_JAKARTA_BARAT\", layer = \"SARANAIBADAH_PT_25K\")\nsaranaibadah_jakbar_sf <- saranaibadah_jakbar |> st_transform(crs = 4326) |> select(REMARK, geometry)\n\nsaranaibadah_jakpus <- st_read(dsn = \"data/geospatial/Jakarta/KOTA_JAKARTA_PUSAT\", layer = \"SARANAIBADAH_PT_25K\")\nsaranaibadah_jakpus_sf <- saranaibadah_jakpus |> st_transform(crs = 4326) |> select(REMARK, geometry)\n\nsaranaibadah_jaksel <- st_read(dsn = \"data/geospatial/Jakarta/KOTA_JAKARTA_SELATAN\", layer = \"SARANAIBADAH_PT_25K\")\nsaranaibadah_jaksel_sf <- saranaibadah_jaksel |> st_transform(crs = 4326) |> select(REMARK, geometry)\n\nsaranaibadah_jakut <- st_read(dsn = \"data/geospatial/Jakarta/KOTA_JAKARTA_UTARA\", layer = \"SARANAIBADAH_PT_25K\")\nsaranaibadah_jakut_sf <- saranaibadah_jakut |> st_transform(crs = 4326) |> select(REMARK, geometry)\n\nsaranaibadah_jaktim <- st_read(dsn = \"data/geospatial/Jakarta/KOTA_JAKARTA_TIMUR\", layer = \"SARANAIBADAH_PT_25K\")\nsaranaibadah_jaktim_sf <- saranaibadah_jaktim |> st_transform(crs = 4326) |> select(REMARK, geometry)\n\nsaranaibadah <- rbind(saranaibadah_jakbar_sf, saranaibadah_jakpus_sf, saranaibadah_jaksel_sf, saranaibadah_jakut_sf, saranaibadah_jaktim_sf) |> st_zm(zm=\"Z\")\n```\n:::\n\n\nCALCULATING MEDIAN DISTANCE BETWEEN SARANAIBADAH\n\nWe will calculate the median distance between each place of worship in Jakarta, which will be used when we are counting the number of POIs within a certain distance from the rental units.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmasjid <- saranaibadah |> filter(REMARK == \"Masjid\")\ngereja <- saranaibadah |> filter(REMARK == \"Gereja\")\nvihara <- saranaibadah |> filter(REMARK == \"Vihara\")\npura <- saranaibadah |> filter(REMARK == \"Pura\")\nother_saranaibadah <- saranaibadah |> filter(REMARK == \"Peribadatan/Sosial Lainnya\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmasjid_dist <- st_distance(masjid)\nmasjid_dist <- data.frame(masjid_dist)\nmasjid_dist <- sapply(masjid_dist, remove_unit)\nmasjid_dist_med <- apply(masjid_dist, 1, median, na.rm = TRUE)\nmasjid_dist_med <- data.frame(masjid_dist_med)\nmasjid_med <- median(masjid_dist_med$masjid_dist_med)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ngereja_dist <- st_distance(gereja)\ngereja_dist <- data.frame(gereja_dist)\ngereja_dist <- sapply(gereja_dist, remove_unit)\ngereja_dist_med <- apply(gereja_dist, 1, median, na.rm = TRUE)\ngereja_dist_med <- data.frame(gereja_dist_med)\ngereja_med <- median(gereja_dist_med$gereja_dist_med)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nvihara_dist <- st_distance(vihara)\nvihara_dist <- data.frame(vihara_dist)\nvihara_dist <- sapply(vihara_dist, remove_unit)\nvihara_dist_med <- apply(vihara_dist, 1, median, na.rm = TRUE)\nvihara_dist_med <- data.frame(vihara_dist_med)\nvihara_med <- median(vihara_dist_med$vihara_dist_med)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\npura_dist <- st_distance(pura)\npura_dist <- data.frame(pura_dist)\npura_dist <- sapply(pura_dist, remove_unit)\npura_dist_med <- apply(pura_dist, 1, median, na.rm = TRUE)\npura_dist_med <- data.frame(pura_dist_med)\npura_med <- median(pura_dist_med$pura_dist_med)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nother_saranaibadah_dist <- st_distance(other_saranaibadah)\nother_saranaibadah_dist <- data.frame(other_saranaibadah_dist)\nother_saranaibadah_dist <- sapply(other_saranaibadah_dist, remove_unit)\nother_saranaibadah_dist_med <- apply(other_saranaibadah_dist, 1, median, na.rm = TRUE)\nother_saranaibadah_dist_med <- data.frame(other_saranaibadah_dist_med)\nother_saranaibadah_med <- median(other_saranaibadah_dist_med$other_saranaibadah_dist_med)\n```\n:::\n\n\n### Combining the data of the POIs\n\nAfter getting all the data of the POI, we will now combine them into one single dataframe\n\n\n::: {.cell}\n\n```{.r .cell-code}\npoi <- rbind(airport, stasiunka, kesehatan, pendidikan, kantorpos, saranaibadah)\n```\n:::\n\n\n### Distance Calculation\n\n#### Calculating the distance matrix of each rental unit to each POI\n\nIn order to examine the influence of the POIs to the rent price of the rental units, we need to calculate the distance matrix between each of the rental units and each of the POIs. To find the distance, we can use st_distance() function from the sf package.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndistance <- st_distance(mamikos_sf, poi)\ndistance <- data.frame(distance)\ncolnames(distance) <- poi$REMARK\nrownames(distance) <- mamikos_sf$`_id`\n```\n:::\n\n\nTo make it easier for us to read and process the data, we need to remove the unit from the distance in the data frame and change the data type to numeric. We also need to pivot the data frame so that it can be easier for us to process the data when finding the minimum proximity to the POIs and the number of POIs within the median distance that we calculated earlier. We also save the data into an RDS file so that we can just call it when we want to use it in the future.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndistance <- sapply(distance, rm_unit)\nrownames(distance) <- mamikos_sf$`_id`\ndistance <- as.data.frame(distance)\ndistance$id <- as.numeric(rownames(distance))\ndistance_pair <- distance |> pivot_longer(!id, names_to = \"POI\", values_to = \"Distance\")\nsaveRDS(distance_pair, \"rds/distance_pair.rds\")\n```\n:::\n\n\n#### Finding the nearest distance to each POI for each rental unit\n\nIn order to find the nearest distance to each POI for each rental unit, we can use the dplyr package to group the data by the rental unit id and the POI, then summarize the data by finding the minimum distance. We can also pivot the data so that it can be easier for us to process the data when we want to join it with the mamikos dataset. We also save the data into an RDS file so that we can just call it when we want to use it in the future.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndistance_min_prox <- distance_pair |> \n  group_by(id, POI) |> \n  summarise(min_distance = min(Distance)) |>\n  pivot_wider(names_from = POI, values_from = min_distance)\n\nsaveRDS(distance_min_prox, \"rds/distance_min_prox.rds\")\n```\n:::\n\n\n#### Counting the number of POIs within the median distance for each rental unit\n\nTo count the number of POIs within the median distance for each rental unit, we need to group by the id of each rental unit then use the `summarise()` function from the dplyr package to count the number of POIs within the median distance. We also save the data into an RDS file so that we can just call it when we want to use it in the future.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndistance_within <- distance_pair |>\n  group_by(id) |> \n  summarise(airport_within_10km = sum(POI == \"AIRPORT\" & Distance <= 10000), \n            stasiunka_within_med = sum(POI == \"STASIUNKA\" & Distance <= stasiunka_med), \n            kesehatan_within_med = sum(POI == \"KESEHATAN\" & Distance <= kesehatan_med), \n            kantorpos_within_med = sum(POI == \"KANTORPOS\" & Distance <= kantorpos_med), \n            masjid_within_med = sum(POI == \"Masjid\" & Distance <= masjid_med),\n            gereja_within_med = sum(POI == \"Gereja\" & Distance <= gereja_med),\n            vihara_within_med = sum(POI == \"Vihara\" & Distance <= vihara_med),\n            pura_within_med = sum(POI == \"Pura\" & Distance <= pura_med),\n            other_saranaibadah_within_med = sum(POI == \"Peribadatan/Sosial Lainnya\" & Distance <= other_saranaibadah_med),\n            pendidikan_within_med = sum(POI == \"PENDIDIKAN\" & Distance <= pendidikan_med))\n\n\nsaveRDS(distance_within, \"rds/distance_within.rds\")\n```\n:::\n\n\n#### Combine proximity data and POI count data with the mamikos dataset\n\nAfter finding the minimum proximity and the count of the POIs to each rental unit, we now combine these columns into the mamikos dataset to put it in our model.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmamikos_full <- left_join(mamikos_sf, distance_min_prox, by = c(\"_id\" = \"id\")) |> left_join(distance_within, by = c(\"_id\" = \"id\"))\n\nmamikos_full <- mamikos_full |> \n  rename(\"PROX_AIRPORT\" = \"AIRPORT\", \n         \"PROX_STASIUNKA\" = \"STASIUNKA\", \n         \"PROX_KESEHATAN\" = \"KESEHATAN\", \n         \"PROX_PENDIDIKAN\" = \"PENDIDIKAN\",\n         \"PROX_KANTORPOS\" = \"KANTORPOS\", \n         \"PROX_MASJID\" = \"Masjid\", \n         \"PROX_GEREJA\" = \"Gereja\", \n         \"PROX_VIHARA\" = \"Vihara\", \n         \"PROX_PURA\" = \"Pura\", \n         \"PROX_OTHER_SARANAIBADAH\" = \"Peribadatan/Sosial Lainnya\", \n         \"AIRPORT_WITHIN_10KM\" = \"airport_within_10km\", \n         \"STASIUNKA_WITHIN_MED\" = \"stasiunka_within_med\", \n         \"KESEHATAN_WITHIN_MED\" = \"kesehatan_within_med\", \n         \"PENDIDIKAN_WITHIN_MED\" = \"pendidikan_within_med\", \n         \"KANTORPOS_WITHIN_MED\" = \"kantorpos_within_med\", \n         \"MASJID_WITHIN_MED\" = \"masjid_within_med\", \n         \"GEREJA_WITHIN_MED\" = \"gereja_within_med\", \n         \"VIHARA_WITHIN_MED\" = \"vihara_within_med\", \n         \"PURA_WITHIN_MED\" = \"pura_within_med\", \n         \"OTHER_SARANAIBADAH_WITHIN_MED\" = \"other_saranaibadah_within_med\")\n\nnames(mamikos_full) <- tolower(names(mamikos_full))\nsaveRDS(mamikos_full, \"rds/mamikos_full.rds\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmamikos_full <- read_rds(\"data/rds/mamikos_full.rds\")\n```\n:::\n\n\n## Exploratory Data Analysis (EDA)\n\n### Statistical Graphics\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(mamikos_full, aes(x = price_monthly)) +\n  geom_histogram(bins = 30, fill = \"#2caa4a\", color = \"black\") +\n  labs(title = \"Monthly Price Distribution\",\n       x = \"Monthly Price (IDR)\",\n       y = \"Frequency\")\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex03_files/figure-html/unnamed-chunk-38-1.png){width=672}\n:::\n:::\n\n\nYou can see that the distribution of the selling price is right-skewed, with a long tail to the right. This skewed distribution is typical of real estate prices, where most of the properties are sold at a lower price, with a few sold at a much higher price.\n\nHowever, working with the raw selling price can be problematic, especially when the distribution is skewed. We can transform the selling price using the natural logarithm to make the distribution more symmetric.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmamikos_full <- mamikos_full |>\n  mutate(log_price = log(price_monthly))\n```\n:::\n\n\nNow let’s plot the distribution of the log-transformed selling price.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(mamikos_full, aes(x = log_price)) +\n  geom_histogram(bins = 30, fill = \"#2caa4a\", color = \"black\") +\n  labs(title = \"Log-Transformed Monthly Price Distribution\",\n       x = \"Log Monthly Price (IDR)\",\n       y = \"Frequency\")\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex03_files/figure-html/unnamed-chunk-40-1.png){width=672}\n:::\n:::\n\n\nNotice that the distribution of the log-transformed selling price is more symmetric compared to the raw selling price. This transformation will be useful when we calibrate the pricing model.\n\n### Visualizing the relationships of the independent variable\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmamikos_no_geo <- mamikos_full |> \n  st_drop_geometry() |> \n  select(-c(\"x_id\", \"price_monthly\"))\n\ncorrplot(cor(mamikos_no_geo),\n         diag = FALSE, \n         order = \"AOE\",\n         tl.pos = \"td\",\n         tl.cex = 0.5, \n         method = \"number\", \n         type = \"upper\")\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex03_files/figure-html/unnamed-chunk-41-1.png){width=1152}\n:::\n:::\n\n\nWe can see that there are a lot of correlated variables in the dataset. For the sake of simplicity of this prototype, we will examine the `size`, `gender`, and `kesehatan_within_med` (places of worship) variables.\n\n### Multiple Histogram Plots distribution of variables\n\nWe will now draw a small multiples of histograms to visualise the distribution of the independent variables.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntmap_mode(\"plot\")\nsize_hist <- ggplot(mamikos_full, aes(x = size)) +\n  geom_histogram(bins = 30, fill = \"#2caa4a\", color = \"black\") +\n  labs(title = \"Size Distribution\",\n       x = \"Size (m2)\",\n       y = \"Frequency\")\n\ngender_hist <- ggplot(mamikos_full, aes(x = gender)) +\n  geom_bar(fill = \"#2caa4a\", color = \"black\") +\n  labs(title = \"Gender Distribution\",\n       x = \"Gender\",\n       y = \"Frequency\")\n\nkesehatan_hist <- ggplot(mamikos_full, aes(x = kesehatan_within_med)) +\n  geom_histogram(fill = \"#2caa4a\", color = \"black\") +\n  labs(title = \"Kesehatan Occurence Distribution\",\n       x = \"Count of Health Facilities\",\n       y = \"Frequency\")\n\nggarrange(size_hist, gender_hist, kesehatan_hist, ncol = 3)\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex03_files/figure-html/unnamed-chunk-42-1.png){width=960}\n:::\n:::\n\n\n### Drawing Statistical Point Map\n\nNow we will draw a statistical point map to visualise the distribution of the log-transformed monthly price of the mamikos units. The code below will create a statistical point map using the tmap package.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(jakarta_sf)+\n  tm_polygons() +\ntm_shape(mamikos_full) +  \n  tm_dots(col = \"log_price\",\n          alpha = 0.6,\n          style=\"quantile\")\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex03_files/figure-html/unnamed-chunk-43-1.png){width=672}\n:::\n:::\n\n\n## Geographically Weighted Regression (GWR)\n\nNow we will perform a Geographically Weighted Regression (GWR) with **adaptive bandwidth** to model the relationship between the monthly rental price of the units and the independent variables. We will use the `GWmodel` package to perform the GWR.\n\n### Creating a SpatialPointsDataFrame\n\nWe will convert `mamikos_full` from simple feature object into a SpatialPointsDataFrame because spdep package can only process sp conformed spatial data objects.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmamikos_sp <- as_Spatial(mamikos_full)\n```\n:::\n\n\n### Computing the Bandwidth\n\nThe first step in calibrating the GWR model is to compute the bandwidth. The bandwidth is a critical parameter in the GWR model as it determines the number of observations that will be used to calibrate the local regression model. Notice that the argument adaptive is set to FALSE indicates that we are interested to compute the fixed bandwidth.\n\nThere are several methods to compute the bandwidth, they are: CV cross-validation approach and AIC corrected (AICc) approach. In this example, we will use the cross-validation (CV) method to compute the bandwidth. The CV method is a robust method to compute the bandwidth as it minimizes the prediction error of the GWR model.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbw <- bw.gwr(formula = log_price ~ size + gender + kesehatan_within_med, \n                   data=mamikos_sp, \n                   approach=\"CV\", \n                   kernel=\"gaussian\", \n                   adaptive=TRUE, \n                   longlat=FALSE,\n                   parallel.method = \"omp\")\n\nwrite_rds(bw, \"data/rds/bw.rds\")\n```\n:::\n\n::: {.cell}\n\n:::\n\n\nThe result shows that the optimal bandwidth is 19 neighbors. This means that the GWR model will use 19 observations to calibrate the local regression model for each observation in the dataset.\n\n### Calibrating the GWR Model\n\nThe code chunk below will calibrate the GWR model using the recommended bandwidth.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngwr <- gwr.robust(formula = log_price ~ size + gender + kesehatan_within_med, \n                          data=mamikos_sp, bw=bw, \n                          kernel = 'gaussian', \n                          adaptive=TRUE, \n                          longlat = FALSE,\n                          parallel.method = \"omp\")\n\nwrite_rds(gwr, \"data/rds/gwr.rds\")\n```\n:::\n\n::: {.cell}\n\n:::\n\n\n## Visualizing GWR Output\n\nThe output of the GWR model are stored in a SpatialPointsDataFrame or SpatialPolygonsDataFrame object integrated with fit.points, GWR coefficient estimates, y value, predicted values, coefficient standard errors and t-values in its “data” slot in an object called SDF of the output list.\n\n### Converting SDF into sf data.frame\n\nTo visualize the fields in SDF, we need to first covert it into sf data.frame by using the code chunk below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngwr_sf <- gwr$SDF |> st_as_sf() |> st_transform(crs = 4326)\n```\n:::\n\n\n### Visualizing local R2\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmamikos_palette <- colorRampPalette(c(\"#f95516\", \"#dbdbdb\", \"#2caa4a\"))(100)\n\ntm_shape(jakarta_sf)+\n  tm_polygons() +\ntm_shape(gwr_sf) +\n  tm_dots(col = \"Local_R2\", \n          style = \"quantile\", \n          palette = mamikos_palette,\n          title = \"Local R2\",\n          midpoint = 0)\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex03_files/figure-html/unnamed-chunk-50-1.png){width=672}\n:::\n:::\n\n\n### Visualizing the GWR Coefficients\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(jakarta_sf)+\n  tm_polygons() +\ntm_shape(gwr_sf) +\n  tm_dots(col = \"size\", \n          style = \"quantile\", \n          palette = mamikos_palette, \n          title = \"Size Coefficient\",\n          midpoint = 0)\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex03_files/figure-html/unnamed-chunk-51-1.png){width=672}\n:::\n:::\n\n\n### Visualizing the GWR Standard Errors\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(jakarta_sf) +\n  tm_polygons() +\ntm_shape(gwr_sf) +\n  tm_dots(col = \"size_SE\", \n          style = \"quantile\", \n          palette = rev(mamikos_palette), \n          title = \"Size Standard Error\",\n          midpoint = 0)\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex03_files/figure-html/unnamed-chunk-52-1.png){width=672}\n:::\n:::\n\n\n## UI Design\n\nThe UI design of the application is shown below:\n\n![UI Design](data/UI.png)\n\nThe user will be able to choose the region, the variables that they are interested in to analyse, and the bandwidth. The graph will then be displayed accordingly to the user's inputs.\n",
    "supporting": [
      "Take-home_Ex03_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}