---
title: "Hands-on Exercise 3: 1st and 2nd Order Spatial Point Patterns Analysis Methods"
format: 
  html:
    toc-depth: 3
author: "Alexander Vincent Lewi"
date: "20 January 2024"
execute: 
  message: false
  warning: false
---

## Overview

This exercise will introduce you to the basic methods of spatial point pattern analysis. We will use the `spatstat` package for this exercise. The `spatstat` package is a comprehensive package for the analysis of spatial point patterns. It is a very powerful package, but it is also very complex. We will only be using a small subset of the functionality of the package. For more information on the `spatstat` package, see the [spatstat website](https://www.spatstat.org/).

In this exercise, we aim to discover the spatial point processes of childecare centres in Singapore by answering the following questions:

-   are the childcare centres in Singapore randomly distributed throughout the country?
-   if the answer is not, then the next logical question is where are the locations with higher concentration of childcare centres?

### The Data

We will use 3 data sets for this exercise:

-   `CHILDCARE`, a point feature data providing both location and attribute information of childcare centres. It was downloaded from [data.gov.sg](https://beta.data.gov.sg/collections/2015/datasets/d_5d668e3f544335f8028f546827b773b4/view) and is in geojson format.
-   `MP14_SUBZONE_WEB_PL`, a polygon feature data providing information of URA 2014 Master Plan Planning Subzone boundary data. It is in ESRI shapefile format. This data set was also downloaded from Data.gov.sg.
-   `CostalOutline`, a polygon feature data showing the national boundary of Singapore. It is provided by SLA and is in ESRI shapefile format.

### Installing and Loading the R packages

In this exercise, we will use the following R packages:

-   **sf**, a relatively new R package specially designed to import, manage and process vector-based geospatial data in R.
-   **spatstat**, which has a wide range of useful functions for point pattern analysis. In this hands-on exercise, it will be used to perform 1st- and 2nd-order spatial point patterns analysis and derive kernel density estimation (KDE) layer.
-   **raster** which reads, writes, manipulates, analyses and model of gridded spatial data (i.e. raster). In this hands-on exercise, it will be used to convert image output generate by spatstat into raster format.
-   **maptools** which provides a set of tools for manipulating geographic data. In this hands-on exercise, we mainly use it to convert Spatial objects into ppp format of spatstat.
-   **tmap** which provides functions for plotting cartographic quality static point patterns maps or interactive maps by using leaflet API.

```{r}
pacman::p_load(maptools, sf, raster, spatstat, tmap)
```

## Data Wrangling

### Spatial Data Wrangling

#### Importing the Data

We will first import the data into R. We will use the `sf` package to import the geojson file and the `maptools` package to import the shapefiles. We will also convert the imported data into the same coordinate reference system (CRS) as the `CostalOutline` data set.

```{r}
childcare_sf <- st_read("data/ChildCareServices.geojson") |>
  st_transform(crs = 3414)
sg_sf <- st_read(dsn = "data/geospatial", layer="CostalOutline")
mpsz_sf <- st_read(dsn = "data/geospatial", layer = "MP14_SUBZONE_WEB_PL")
```

Before we proceed, let's take a look at the imported data.

```{r}
st_crs(childcare_sf)
st_crs(sg_sf)
st_crs(mpsz_sf)
```

Notice that except childcare_sf, both mpsz_sf and sg_sf do not have proper crs information. You will notice that `sg_sf` and `mpsz_sf` is in SVY21, but their EPSG code is 9001.

```{r}
#| code-summary: Assign the correct crs to mpsz_sf and sg_sf simple feature data frames.
sg_sf <- st_set_crs(sg_sf, 3414)
mpsz_sf <- st_set_crs(mpsz_sf, 3414)
```

#### Mapping the geospatial data sets

Let's map the geospatial data sets to see what they look like.

```{r}
tmap_mode("plot")
qtm(mpsz_sf) +
  qtm(childcare_sf)
```

We can see that the geospatial layers are aligned. This shows that their referencing system and coordinate values are referred to similar spatial context. This is very important in any geospatial analysis.

Alternatively, we can also prepare a pin map by using the code chunk below.

```{r}
tmap_mode('view')
tm_shape(childcare_sf)+
  tm_dots()
```

> Reminder: Always remember to switch back to plot mode after the interactive map. This is because, each interactive mode will consume a connection. You should also avoid displaying ecessive numbers of interactive maps (i.e. not more than 10) in one RMarkdown document when publish on Netlify.

```{r}
tmap_mode('plot')
```

### Geospatial Data Wrangling

#### Converting sf data frames to sp’s Spatial\* class

We will now convert the `sf` data frames to `sp` Spatial\* class. This is because the `spatstat` package only accepts `sp` Spatial\* class as input.

```{r}
childcare <- as_Spatial(childcare_sf)
mpsz <- as_Spatial(mpsz_sf)
sg <- as_Spatial(sg_sf)
```

```{r}
childcare
```

```{r}
mpsz
```

```{r}
sg
```

#### Converting the Spatial\* class into generic sp format

#### Converting the Spatial\* class into generic sp format

**spatstat** requires the analytical data in **ppp** object form. There is no direct way to convert a Spatial\* classes into **ppp** object. We need to convert the **Spatial classes\*** into **Spatial** object first.

The codes chunk below converts the Spatial\* classes into generic sp objects.

```{r}
childcare_sp <- as(childcare, "SpatialPoints")
sg_sp <- as(sg, "SpatialPolygons")
```

Next, you should display the sp objects properties as shown below.

```{r}
childcare_sp
```

```{r}
sg_sp
```

However, the sp objects do not contain the CRS information. This is important because **spatstat** requires the analytical data to be in **ppp** object form. The **ppp** object requires the analytical data to be in **sp** objects form. Therefore, we need to convert the sp objects into **ppp** objects.

#### Converting the sp objects into ppp objects

Now, we will use as.ppp() function of spatstat to convert the spatial data into spatstat’s ppp object format.

```{r}
childcare_ppp <- as.ppp(childcare_sp)
```

Let's plot the ppp object to see what it looks like.

```{r}
plot(childcare_ppp)
```

You can take a look at the ppp object properties by using the code chunk below.

```{r}
summary(childcare_ppp)
```

Notice the warning message about duplicates. In spatial point patterns analysis an issue of significant is the presence of duplicates. The statistical methodology used for spatial point patterns processes is based largely on the assumption that process are simple, that is, that the points cannot be coincident.

#### Handling the duplicates

We can check the duplication in a ppp object by using the code chunk below.

```{r}
any(duplicated(childcare_ppp))
```

To count the number of co-indicence point, we will use the multiplicity() function as shown in the code chunk below.

```{r}
#| eval: false
multiplicity(childcare_ppp)
```

If we want to know how many locations have more than one point event, we can use the code chunk below.

```{r}
sum(multiplicity(childcare_ppp) > 1)
```

The output shows that there are 338 duplicated point events.

To view the locations of these duplicate point events, we will plot childcare data by using the code chunk below.

```{r}
tmap_mode('view')
tm_shape(childcare) +
  tm_dots(alpha=0.4, 
          size=0.05)
tmap_mode('plot')
```

You can tell the duplicated points by looking at the darker spots.

There are three ways to handle the duplicates:

-   Remove the duplicates. This is the easiest way to handle the duplicates. However, it is not recommended because it will result in loss of information.
-   Add a small amount of random noise to the duplicated points. This is the most common way to handle the duplicates.
-   The third way is to make each point unique by adding a unique identifier to each point as **marks**. This is the most recommended way to handle the duplicates. However, it is also the most tedious way to handle the duplicates.

We will use the second method to handle the duplicates. We will use the jitter() function to add a small amount of random noise to the duplicated points. The code chunk below shows how to do it.

```{r}
childcare_ppp_jit <- rjitter(childcare_ppp)
any(duplicated(childcare_ppp_jit))
```

#### Creating owin object

When analysing spatial point patterns, it is a good practice to confine the analysis with a geographical area like Singapore boundary. In spatstat, an object called owin is specially designed to represent this polygonal region.

The code chunk below is used to covert sg SpatialPolygon object into owin object of spatstat.

```{r}
sg_owin <- as(sg_sp, "owin")
```

the output can be viewed by using the `plot()`

```{r}
plot(sg_owin)
```

and `summary()`

```{r}
summary(sg_owin)
```

#### Combining point events object and owin object

In this last step of geospatial data wrangling, we will extract childcare events that are located within Singapore by using the code chunk below.

```{r}
childcareSG_ppp = childcare_ppp[sg_owin]
plot(childcareSG_ppp)
```

## 1st Order Spatial Point Patterns Analysis

This section will introduce you to the basic methods of 1st order spatial point patterns analysis. We will use the `spatstat` package for this exercise. This section will focus on:

-   deriving kernel density estimation (KDE) layer for visualising and exploring the intensity of point processes,
-   performing Confirmatory Spatial Point Patterns Analysis by using Nearest Neighbour statistics.

### Kernel Density Estimation

The code chunk below computes a kernel density by using the following configurations of density() of spatstat:

-   bw.diggle() automatic bandwidth selection method. Other recommended methods are bw.CvL(), bw.scott() or bw.ppl().
-   The smoothing kernel used is gaussian, which is the default. Other smoothing methods are: “epanechnikov”, “quartic” or “disc”.
-   The intensity estimate is corrected for edge effect bias by using method described by Jones (1993) and Diggle (2010, equation 18.9). The default is FALSE.

```{r}
kde_childcareSG_bw <- density(childcareSG_ppp,
                              sigma=bw.diggle,
                              edge=TRUE,
                              kernel="gaussian") 
plot(kde_childcareSG_bw)
```

The density values of the output range from 0 to 0.000035 which is way too small to comprehend. This is because the default unit of measurement of svy21 is in meter. As a result, the density values computed is in “number of points per square meter”.

Before we move on to next section, it is good to know that you can retrieve the bandwidth used to compute the kde layer by using the code chunk below.

```{r}
bw <- bw.diggle(childcareSG_ppp)
bw
```

To make the density values more comprehensible, we will rescale the density values from meter to kilometer using `rescale()`.

```{r}
childcareSG_ppp.km <- rescale(childcareSG_ppp, 1000, "km")
```

Now, we can re-run the density() function to compute the kde map.

```{r}
kde_childcareSG.bw <- density(childcareSG_ppp.km, sigma=bw.diggle, edge=TRUE, kernel="gaussian")
plot(kde_childcareSG.bw)
```

#### Working with different automatic badwidth methods

Besides bw.diggle(), there are other automatic bandwidth selection methods that you can Beside bw.diggle(), there are three other spatstat functions can be used to determine the bandwidth, they are: bw.CvL(), bw.scott(), and bw.ppl().

Let us take a look at the bandwidth return by these automatic bandwidth calculation methods by using the code chunk below.

```{r}
for (bw in c("bw.diggle", "bw.CvL", "bw.scott", "bw.ppl")) {
  print(bw)
  print(get(bw)(childcareSG_ppp.km))
}
```

Baddeley et. (2016) suggested the use of the bw.ppl() algorithm because in ther experience it tends to produce the more appropriate values when the pattern consists predominantly of tight clusters. But they also insist that if the purpose of once study is to detect a single tight cluster in the midst of random noise then the bw.diggle() method seems to work best.

The code chunk beow will be used to compare the output of using bw.diggle and bw.ppl methods.

```{r}
kde_childcareSG.ppl <- density(childcareSG_ppp.km, 
                               sigma=bw.ppl, 
                               edge=TRUE,
                               kernel="gaussian")
par(mfrow=c(1,2))
plot(kde_childcareSG.bw, main = "bw.diggle")
plot(kde_childcareSG.ppl, main = "bw.ppl")
```

#### Working with different kernel methods

By default, the kernel method used in density.ppp() is gaussian. But there are three other options, namely: Epanechnikov, Quartic and Dics.

The code chunk below will be used to compute three more kernel density estimations by using these three kernel function.

```{r}
par(mfrow=c(2,2))
plot(density(childcareSG_ppp.km, 
             sigma=bw.ppl, 
             edge=TRUE, 
             kernel="gaussian"), 
     main="Gaussian")
plot(density(childcareSG_ppp.km, 
             sigma=bw.ppl, 
             edge=TRUE, 
             kernel="epanechnikov"), 
     main="Epanechnikov")
plot(density(childcareSG_ppp.km, 
             sigma=bw.ppl, 
             edge=TRUE, 
             kernel="quartic"), 
     main="Quartic")
plot(density(childcareSG_ppp.km, 
             sigma=bw.ppl, 
             edge=TRUE, 
             kernel="disc"), 
     main="Disc")
```

### Fixed and Adaptive KDE

#### Computing KDE by using fixed bandwidth

Next, you will compute a KDE layer by defining a bandwidth of 600 meter. Notice that in the code chunk below, the sigma value used is 0.6. This is because the unit of measurement of childcareSG_ppp.km object is in kilometer, hence the 600m is 0.6km.

```{r}
kde_childcareSG_600 <- density(childcareSG_ppp.km, sigma=0.6, edge=TRUE, kernel="gaussian")
plot(kde_childcareSG_600)
```

#### Computing KDE by using adaptive bandwidth

Fixed bandwidth method is very sensitive to highly skew distribution of spatial point patterns over geographical units for example urban versus rural. One way to overcome this problem is by using adaptive bandwidth instead.

In this section, you will learn how to derive adaptive kernel density estimation by using [density.adaptive()](https://rdrr.io/cran/spatstat/man/adaptive.density.html) of **spatstat**.

```{r}
kde_childcareSG_adaptive <- adaptive.density(childcareSG_ppp.km, method="kernel")
plot(kde_childcareSG_adaptive)
```

We can compare the fixed and adaptive kernel density estimation outputs by using the code chunk below.

```{r}
par(mfrow=c(1,2))
plot(kde_childcareSG.bw, main = "Fixed bandwidth")
plot(kde_childcareSG_adaptive, main = "Adaptive bandwidth")
```

#### Converting KDE output into grid object.

The result is the same, we just convert it so that it is suitable for mapping purposes

```{r}
gridded_kde_childcareSG_bw <- as.SpatialGridDataFrame.im(kde_childcareSG.bw)
spplot(gridded_kde_childcareSG_bw)
```

##### Converting gridded output into raste

Next, we will convert the gridded kernal density objects into RasterLayer object by using raster() of raster package.

```{r}
kde_childcareSG_bw_raster <- raster(gridded_kde_childcareSG_bw)
```

Let us take a look at the properties of kde_childcareSG_bw_raster RasterLayer.

```{r}
kde_childcareSG_bw_raster
```

Notice that the crs property is NA.

##### Assigning projection systems

The code chunk below will be used to include the CRS information on kde_childcareSG_bw_raster RasterLayer.

```{r}
projection(kde_childcareSG_bw_raster) <- CRS("+init=EPSG:3414")
kde_childcareSG_bw_raster
```

Notice that the crs property is completed.

#### Visualising the output in tmap

Finally, we will display the raster in cartographic quality map using tmap package.

```{r}
tm_shape(kde_childcareSG_bw_raster) + 
  tm_raster("v") +
  tm_layout(legend.position = c("right", "bottom"), frame = FALSE)
```

Notice that the raster values are encoded explicitly onto the raster pixel using the values in “v” field.

#### Comparing Spatial Point Patterns using KDE

This section will show you how to compare KDE of childcare at Ponggol, Tampines, Chua Chu Kang and Jurong West planning areas.

```{r}
#| code-folding: true
#| code-summary: Extracting the study area
pg = mpsz[mpsz@data$PLN_AREA_N == "PUNGGOL",]
tm = mpsz[mpsz@data$PLN_AREA_N == "TAMPINES",]
ck = mpsz[mpsz@data$PLN_AREA_N == "CHOA CHU KANG",]
jw = mpsz[mpsz@data$PLN_AREA_N == "JURONG WEST",]
```

```{r}
#| code-summary: Plotting target planning areas
par(mfrow=c(2,2))
plot(pg, main = "Ponggol")
plot(tm, main = "Tampines")
plot(ck, main = "Choa Chu Kang")
plot(jw, main = "Jurong West")
```

Next, we will convert these SpatialPolygonsDataFrame layers into generic spatialpolygons layers.

```{r}
#| code-folding: true
#| code-summary: Converting the spatial point data frame into generic sp format
pg_sp = as(pg, "SpatialPolygons")
tm_sp = as(tm, "SpatialPolygons")
ck_sp = as(ck, "SpatialPolygons")
jw_sp = as(jw, "SpatialPolygons")
```

Now, we will convert these SpatialPolygons objects into owin objects that is required by **spatstat**.

```{r}
#| code-folding: true
#| code-summary: Creating owin object
pg_owin = as(pg_sp, "owin")
tm_owin = as(tm_sp, "owin")
ck_owin = as(ck_sp, "owin")
jw_owin = as(jw_sp, "owin")
```

By using the code chunk below, we are able to extract childcare that is within the specific region to do our analysis later on.

```{r}
#| code-folding: true
#| code-summary: Combining childcare points and the study area
childcare_pg_ppp = childcare_ppp_jit[pg_owin]
childcare_tm_ppp = childcare_ppp_jit[tm_owin]
childcare_ck_ppp = childcare_ppp_jit[ck_owin]
childcare_jw_ppp = childcare_ppp_jit[jw_owin]
```

Next, **rescale()** function is used to trasnform the unit of measurement from metre to kilometre.

```{r}
#| code-folding: true
#| code-summary: Rescalling the unit of measurement
childcare_pg_ppp.km = rescale(childcare_pg_ppp, 1000, "km")
childcare_tm_ppp.km = rescale(childcare_tm_ppp, 1000, "km")
childcare_ck_ppp.km = rescale(childcare_ck_ppp, 1000, "km")
childcare_jw_ppp.km = rescale(childcare_jw_ppp, 1000, "km")
```

The code chunk below is used to plot these four study areas and the locations of the childcare centres.

```{r}
#| code-folding: true
#| code-summary: Plotting the study areas and the locations of the childcare centres
par(mfrow=c(2,2))
plot(childcare_pg_ppp.km, main="Punggol")
plot(childcare_tm_ppp.km, main="Tampines")
plot(childcare_ck_ppp.km, main="Choa Chu Kang")
plot(childcare_jw_ppp.km, main="Jurong West")
```

The code chunk below will be used to compute the KDE of these four planning area. bw.diggle method is used to derive the bandwidth of each planning area.

```{r}
#| code-folding: true
#| code-summary: Computing the KDE of the four planning areas
par(mfrow=c(2,2))
plot(density(childcare_pg_ppp.km, 
             sigma=bw.diggle, 
             edge=TRUE, 
             kernel="gaussian"),
     main="Punggol")
plot(density(childcare_tm_ppp.km, 
             sigma=bw.diggle, 
             edge=TRUE, 
             kernel="gaussian"),
     main="Tempines")
plot(density(childcare_ck_ppp.km, 
             sigma=bw.diggle, 
             edge=TRUE, 
             kernel="gaussian"),
     main="Choa Chu Kang")
plot(density(childcare_jw_ppp.km, 
             sigma=bw.diggle, 
             edge=TRUE, 
             kernel="gaussian"),
     main="JUrong West")
```

For comparison purposes with fixed bandwidth KDE, we will use 250m as the bandwidth.

```{r}
#| code-folding: true
#| code-summary: fixed bandwidth KDE
par(mfrow=c(2,2))
plot(density(childcare_ck_ppp.km, 
             sigma=0.25, 
             edge=TRUE, 
             kernel="gaussian"),
     main="Chou Chu Kang")
plot(density(childcare_jw_ppp.km, 
             sigma=0.25, 
             edge=TRUE, 
             kernel="gaussian"),
     main="JUrong West")
plot(density(childcare_pg_ppp.km, 
             sigma=0.25, 
             edge=TRUE, 
             kernel="gaussian"),
     main="Punggol")
plot(density(childcare_tm_ppp.km, 
             sigma=0.25, 
             edge=TRUE, 
             kernel="gaussian"),
     main="Tampines")
```

### Nearest Neighbour Analysis

In this section, we will perform the Clark-Evans test of aggregation for a spatial point pattern by using [clarkevans.test()](https://www.rdocumentation.org/packages/spatstat/versions/1.63-3/topics/clarkevans.test) of **statspat**.

The test hypotheses are:

Ho = The distribution of childcare services are randomly distributed.

H1= The distribution of childcare services are not randomly distributed.

The 95% confident interval will be used.

#### Testing spatial point patterns using Clark and Evans Test

```{r}
clarkevans.test(childcareSG_ppp,
                correction="none",
                clipregion="sg_owin",
                alternative=c("clustered"),
                nsim=99)
```

The output shows that the p-value is less than 0.05. Therefore, we reject the null hypothesis and conclude that the distribution of childcare services are not randomly distributed. We can also see that the R value is less than 1. This means that the distribution of childcare services are clustered.

```{r}
#| code-folding: true
#| code-summary: "Clark and Evans Test: Choa Chu Kang planning area"
clarkevans.test(childcare_ck_ppp,
                correction="none",
                clipregion=NULL,
                alternative=c("two.sided"),
                nsim=999)
```

```{r}
#| code-folding: true
#| code-summary: "Clark and Evans Test: Tampines planning area"
clarkevans.test(childcare_tm_ppp,
                correction="none",
                clipregion=NULL,
                alternative=c("two.sided"),
                nsim=999)
```

## 2nd Order Spatial Point Patterns Analysis

### Analysing Spatial Point Process Using G-Function

The G function measures the distribution of the distances from an arbitrary event to its nearest event. In this section, you will learn how to compute G-function estimation by using [Gest()](https://rdrr.io/cran/spatstat/man/Gest.html) of **spatstat** package. You will also learn how to perform monta carlo simulation test using [envelope()](https://rdrr.io/cran/spatstat/man/envelope.html) of **spatstat** package.

#### Choa Chu Kang planning area

The code chunk below is used to compute G-function using Gest() of spatat package.

```{r}
#| code-folding: true
#| code-summary: Computing G-function estimation
G_CK = Gest(childcare_ck_ppp, correction = "border")
plot(G_CK, xlim=c(0,500))
```

To confirm the observed spatial patterns above, a hypothesis test will be conducted. The hypothesis and test are as follows:

Ho = The distribution of childcare services at Choa Chu Kang are randomly distributed.

H1= The distribution of childcare services at Choa Chu Kang are not randomly distributed.

The null hypothesis will be rejected if p-value is smaller than alpha value of 0.001.

Monte Carlo test with G-function

```{r}
#| code-folding: true
#| code-summary: Performing Complete Spatial Randomness Test
G_CK.csr <- envelope(childcare_ck_ppp, Gest, nsim = 999)
plot(G_CK.csr)
```

#### Tampines planning area

```{r}
#| code-folding: true
#| code-summary: Computing G-function estimation
G_tm = Gest(childcare_tm_ppp, correction = "best")
plot(G_tm)
```

To confirm the observed spatial patterns above, a hypothesis test will be conducted. The hypothesis and test are as follows:

Ho = The distribution of childcare services at Choa Chu Kang are randomly distributed.

H1= The distribution of childcare services at Choa Chu Kang are not randomly distributed.

The null hypothesis will be rejected if p-value is smaller than alpha value of 0.001.

Monte Carlo test with G-function

```{r}
#| code-folding: true
#| code-summary: Performing Complete Spatial Randomness Test
G_tm.csr <- envelope(childcare_tm_ppp, Gest, correction = "all", nsim = 999)
plot(G_tm.csr)
```

### Analysing Spatial Point Process Using F-Function

The F function estimates the empty space function F(r) or its hazard rate h(r) from a point pattern in a window of arbitrary shape. In this section, you will learn how to compute F-function estimation by using [Fest()](https://rdrr.io/cran/spatstat/man/Fest.html) of **spatstat** package. You will also learn how to perform monta carlo simulation test using [envelope()](https://rdrr.io/cran/spatstat/man/envelope.html) of **spatstat** package.

#### Choa Chu Kang planning area

The code chunk below is used to compute F-function using Fest() of spatat package.

```{r}
#| code-folding: true
#| code-summary: Computing F-function estimation
F_CK = Fest(childcare_ck_ppp)
plot(F_CK)
```

To confirm the observed spatial patterns above, a hypothesis test will be conducted. The hypothesis and test are as follows:

Ho = The distribution of childcare services at Choa Chu Kang are randomly distributed.

H1= The distribution of childcare services at Choa Chu Kang are not randomly distributed.

The null hypothesis will be rejected if p-value is smaller than alpha value of 0.001.

Monte Carlo test with F-function

```{r}
#| code-folding: true
#| code-summary: Performing Complete Spatial Randomness Test
F_CK.csr <- envelope(childcare_ck_ppp, Fest, nsim = 999)
plot(F_CK.csr)

```

#### Tampines planning area

```{r}
#| code-folding: true
#| code-summary: Computing F-function estimation
F_tm = Fest(childcare_tm_ppp, correction = "best")
plot(F_tm)
```

To confirm the observed spatial patterns above, a hypothesis test will be conducted. The hypothesis and test are as follows:

Ho = The distribution of childcare services at Tampines are randomly distributed.

H1= The distribution of childcare services at Tampines are not randomly distributed.

The null hypothesis will be rejected is p-value is smaller than alpha value of 0.001.

The code chunk below is used to perform the hypothesis testing.

```{r}
#| code-folding: true
#| code-summary: Performing Complete Spatial Randomness Test
F_tm.csr <- envelope(childcare_tm_ppp, Fest, correction = "all", nsim = 999)
plot(F_tm.csr)
```

### Analysing Spatial Point Process Using K-Function

K-function measures the number of events found up to a given distance of any particular event. In this section, you will learn how to compute K-function estimates by using [Kest()](https://rdrr.io/cran/spatstat/man/Kest.html) of **spatstat** package. You will also learn how to perform monta carlo simulation test using envelope() of **spatstat** package.

#### Choa Chu Kang planning area

```{r}
#| code-folding: true
#| code-summary: Computing K-function estimation
K_ck = Kest(childcare_ck_ppp, correction = "Ripley")
plot(K_ck, . -r ~ r, ylab= "K(d)-r", xlab = "d(m)")
```

To confirm the observed spatial patterns above, a hypothesis test will be conducted. The hypothesis and test are as follows:

Ho = The distribution of childcare services at Choa Chu Kang are randomly distributed.

H1= The distribution of childcare services at Choa Chu Kang are not randomly distributed.

The null hypothesis will be rejected if p-value is smaller than alpha value of 0.001.

The code chunk below is used to perform the hypothesis testing.

```{r}
#| code-folding: true
#| code-summary: Performing Complete Spatial Randomness Test
K_ck.csr <- envelope(childcare_ck_ppp, Kest, nsim = 99, rank = 1, glocal=TRUE)
plot(K_ck.csr)

```

#### Tampines planning area

```{r}
#| code-folding: true
#| code-summary: Computing K-function estimation
K_tm = Kest(childcare_tm_ppp, correction = "Ripley")
plot(K_tm, . -r ~ r, 
     ylab= "K(d)-r", 
     xlab = "d(m)", 
     xlim=c(0,1000))
```

To confirm the observed spatial patterns above, a hypothesis test will be conducted. The hypothesis and test are as follows:

Ho = The distribution of childcare services at Tampines are randomly distributed.

H1= The distribution of childcare services at Tampines are not randomly distributed.

The null hypothesis will be rejected if p-value is smaller than alpha value of 0.001.

The code chunk below is used to perform the hypothesis testing.

```{r}
#| code-folding: true
#| code-summary: Performing Complete Spatial Randomness Test
K_tm.csr <- envelope(childcare_tm_ppp, Kest, nsim = 99, rank = 1, glocal=TRUE)
plot(K_tm.csr, . - r ~ r, 
     xlab="d", 
     ylab="K(d)-r", 
     xlim=c(0,500))
```

### Analysing Spatial Point Process Using L-Function

In this section, you will learn how to compute L-function estimation by using [Lest()](https://rdrr.io/cran/spatstat/man/Lest.html) of **spatstat** package. You will also learn how to perform monta carlo simulation test using envelope() of **spatstat** package.

#### Choa Chu Kang planning area

```{r}
#| code-folding: true
#| code-summary: Computing L-function estimation
L_ck = Lest(childcare_ck_ppp, correction = "Ripley")
plot(L_ck, . -r ~ r, 
     ylab= "L(d)-r", xlab = "d(m)")
```

To confirm the observed spatial patterns above, a hypothesis test will be conducted. The hypothesis and test are as follows:

Ho = The distribution of childcare services at Choa Chu Kang are randomly distributed.

H1= The distribution of childcare services at Choa Chu Kang are not randomly distributed.

The null hypothesis will be rejected if p-value if smaller than alpha value of 0.001.

The code chunk below is used to perform the hypothesis testing.

```{r}
#| code-folding: true
#| code-summary: Performing Complete Spatial Randomness Test
L_ck.csr <- envelope(childcare_ck_ppp, Lest, nsim = 99, rank = 1, glocal=TRUE)
plot(L_ck.csr, . - r ~ r, 
     xlab="d", 
     ylab="L(d)-r")
```

#### Tampines planning area

```{r}
#| code-folding: true
#| code-summary: Computing L-function estimation
L_tm = Lest(childcare_tm_ppp, correction = "Ripley")
plot(L_tm, . -r ~ r, 
     ylab= "L(d)-r", 
     xlab = "d(m)", 
     xlim=c(0,1000))
```

To confirm the observed spatial patterns above, a hypothesis test will be conducted. The hypothesis and test are as follows:

Ho = The distribution of childcare services at Tampines are randomly distributed.

H1= The distribution of childcare services at Tampines are not randomly distributed.

The null hypothesis will be rejected if p-value is smaller than alpha value of 0.001.

The code chunk below will be used to perform the hypothesis testing.

```{r}
#| code-folding: true
#| code-summary: Performing Complete Spatial Randomness Test
L_tm.csr <- envelope(childcare_tm_ppp, Lest, nsim = 99, rank = 1, glocal=TRUE)
plot(L_tm.csr, . - r ~ r, 
     xlab="d", 
     ylab="L(d)-r", 
     xlim=c(0,500))
```
